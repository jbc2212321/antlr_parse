// Code generated from /Users/bytedance/go/src/code.byted.org/lark-approval/ai_sdk/clickhouse_parse/DP.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // DP

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type DPParser struct {
	*antlr.BaseParser
}

var DPParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func dpParserInit() {
	staticData := &DPParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "'false'", "'true'", "", "", "", "", "", "", "'->'",
		"'*'", "'`'", "'\\'", "':'", "','", "'||'", "'-'", "'.'", "'=='", "'='",
		"'>='", "'>'", "'{'", "'['", "'<='", "'('", "'<'", "", "'%'", "'+'",
		"'?'", "'\"'", "'''", "'}'", "']'", "')'", "';'", "'/'", "'_'",
	}
	staticData.SymbolicNames = []string{
		"", "ADD", "AFTER", "ALIAS", "ALL", "ALTER", "AND", "ANTI", "ANY", "ARRAY",
		"AS", "ASCENDING", "ASOF", "AST", "ASYNC", "ATTACH", "BETWEEN", "BOTH",
		"BY", "CASE", "CAST", "CHECK", "CLEAR", "CLUSTER", "CODEC", "COLLATE",
		"COLUMN", "COMMENT", "CONSTRAINT", "CREATE", "CROSS", "CUBE", "CURRENT",
		"DATABASE", "DATABASES", "DATE", "DAY", "DEDUPLICATE", "DEFAULT", "DELAY",
		"DELETE", "DESC", "DESCENDING", "DESCRIBE", "DETACH", "DICTIONARIES",
		"DICTIONARY", "DISK", "DISTINCT", "DISTRIBUTED", "DROP", "ELSE", "END",
		"ENGINE", "EVENTS", "EXISTS", "EXPLAIN", "EXPRESSION", "EXTRACT", "FETCHES",
		"FINAL", "FIRST", "FLUSH", "FOLLOWING", "FOR", "FORMAT", "FREEZE", "FROM",
		"FULL", "FUNCTION", "GLOBAL", "GRANULARITY", "GROUP", "HAVING", "HIERARCHICAL",
		"HOUR", "ID", "IF", "ILIKE", "IN", "INDEX", "INF", "INJECTIVE", "INNER",
		"INSERT", "INTERVAL", "INTO", "IS", "IS_OBJECT_ID", "JOIN", "KEY", "KILL",
		"LAST", "LAYOUT", "LEADING", "LEFT", "LIFETIME", "LIKE", "LIMIT", "LIVE",
		"LOCAL", "LOGS", "MATERIALIZE", "MATERIALIZED", "MAX", "MERGES", "MIN",
		"MINUTE", "MODIFY", "MONTH", "MOVE", "MUTATION", "NAN_SQL", "NO", "NOT",
		"NULL_SQL", "NULLS", "OFFSET", "ON", "OPTIMIZE", "OR", "ORDER", "OUTER",
		"OUTFILE", "OVER", "PARTITION", "POPULATE", "PRECEDING", "PREWHERE",
		"PRIMARY", "PROJECTION", "QUARTER", "RANGE", "RELOAD", "REMOVE", "RENAME",
		"REPLACE", "REPLICA", "REPLICATED", "RIGHT", "ROLLUP", "ROW", "ROWS",
		"SAMPLE", "SECOND", "SELECT", "SEMI", "SENDS", "SET", "SETTINGS", "SHOW",
		"SOURCE", "START", "STOP", "SUBSTRING", "SYNC", "SYNTAX", "SYSTEM",
		"TABLE", "TABLES", "TEALIMIT", "TEMPORARY", "TEST", "THEN", "TIES",
		"TIMEOUT", "TIMESTAMP", "TO", "TOP", "TOTALS", "TRAILING", "TRIM", "TRUNCATE",
		"TTL", "TYPE", "UNBOUNDED", "UNION", "UPDATE", "USE", "USING", "UUID",
		"VALUES", "VIEW", "VOLUME", "WATCH", "WEEK", "WHEN", "WHERE", "WINDOW",
		"WITH", "YEAR", "JSON_FALSE", "JSON_TRUE", "IDENTIFIER", "FLOATING_LITERAL",
		"OCTAL_LITERAL", "DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "STRING_LITERAL",
		"ARROW", "ASTERISK", "BACKQUOTE", "BACKSLASH", "COLON", "COMMA", "CONCAT",
		"DASH", "DOT", "EQ_DOUBLE", "EQ_SINGLE", "GE", "GT", "LBRACE", "LBRACKET",
		"LE", "LPAREN", "LT", "NOT_EQ", "PERCENT", "PLUS", "QUERY", "QUOTE_DOUBLE",
		"QUOTE_SINGLE", "RBRACE", "RBRACKET", "RPAREN", "SEMICOLON", "SLASH",
		"UNDERSCORE", "MULTI_LINE_COMMENT", "SINGLE_LINE_COMMENT", "WHITESPACE",
	}
	staticData.RuleNames = []string{
		"queryStmt", "query", "ctes", "namedQuery", "columnAliases", "selectUnionStmt",
		"selectStmtWithParens", "selectStmt", "withClause", "topClause", "fromClause",
		"arrayJoinClause", "windowClause", "prewhereClause", "whereClause",
		"groupByClause", "havingClause", "orderByClause", "limitByClause", "limitClause",
		"tealimitClause", "settingsClause", "joinExpr", "joinOp", "joinOpCross",
		"joinConstraintClause", "sampleClause", "limitExpr", "tealimitExpr",
		"orderExprList", "orderExpr", "ratioExpr", "settingExprList", "settingExpr",
		"windowExpr", "winPartitionByClause", "winOrderByClause", "winFrameClause",
		"winFrameExtend", "winFrameBound", "columnTypeExpr", "columnExprList",
		"columnsExpr", "columnExpr", "columnArgList", "columnArgExpr", "columnLambdaExpr",
		"columnIdentifier", "nestedIdentifier", "tableExpr", "tableFunctionExpr",
		"tableIdentifier", "tableArgList", "tableArgExpr", "databaseIdentifier",
		"floatingLiteral", "numberLiteral", "literal", "interval", "keyword",
		"keywordForAlias", "alias", "identifier", "identifierOrNull", "enumValue",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 231, 931, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 135, 8, 0, 1, 0,
		1, 0, 3, 0, 139, 8, 0, 1, 0, 3, 0, 142, 8, 0, 1, 1, 3, 1, 145, 8, 1, 1,
		1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 5, 2, 153, 8, 2, 10, 2, 12, 2, 156, 9,
		2, 1, 3, 1, 3, 3, 3, 160, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4, 1,
		4, 1, 4, 1, 4, 5, 4, 171, 8, 4, 10, 4, 12, 4, 174, 9, 4, 1, 4, 1, 4, 1,
		5, 1, 5, 1, 5, 1, 5, 5, 5, 182, 8, 5, 10, 5, 12, 5, 185, 9, 5, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 3, 6, 192, 8, 6, 1, 7, 3, 7, 195, 8, 7, 1, 7, 1, 7,
		3, 7, 199, 8, 7, 1, 7, 3, 7, 202, 8, 7, 1, 7, 1, 7, 3, 7, 206, 8, 7, 1,
		7, 3, 7, 209, 8, 7, 1, 7, 3, 7, 212, 8, 7, 1, 7, 3, 7, 215, 8, 7, 1, 7,
		3, 7, 218, 8, 7, 1, 7, 3, 7, 221, 8, 7, 1, 7, 3, 7, 224, 8, 7, 1, 7, 1,
		7, 3, 7, 228, 8, 7, 1, 7, 1, 7, 3, 7, 232, 8, 7, 1, 7, 3, 7, 235, 8, 7,
		1, 7, 3, 7, 238, 8, 7, 1, 7, 3, 7, 241, 8, 7, 1, 7, 3, 7, 244, 8, 7, 1,
		7, 3, 7, 247, 8, 7, 1, 7, 3, 7, 250, 8, 7, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 259, 8, 9, 1, 10, 1, 10, 1, 10, 1, 11, 3, 11, 265, 8,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 292, 8, 15, 1, 16, 1, 16, 1, 16,
		1, 17, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1,
		19, 1, 19, 1, 19, 3, 19, 310, 8, 19, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21,
		1, 21, 1, 22, 1, 22, 1, 22, 3, 22, 321, 8, 22, 1, 22, 3, 22, 324, 8, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 330, 8, 22, 1, 22, 1, 22, 3, 22, 334,
		8, 22, 1, 22, 3, 22, 337, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 343,
		8, 22, 10, 22, 12, 22, 346, 9, 22, 1, 23, 3, 23, 349, 8, 23, 1, 23, 1,
		23, 1, 23, 3, 23, 354, 8, 23, 1, 23, 3, 23, 357, 8, 23, 1, 23, 3, 23, 360,
		8, 23, 1, 23, 1, 23, 3, 23, 364, 8, 23, 1, 23, 1, 23, 3, 23, 368, 8, 23,
		1, 23, 3, 23, 371, 8, 23, 3, 23, 373, 8, 23, 1, 23, 3, 23, 376, 8, 23,
		1, 23, 1, 23, 3, 23, 380, 8, 23, 1, 23, 1, 23, 3, 23, 384, 8, 23, 1, 23,
		3, 23, 387, 8, 23, 3, 23, 389, 8, 23, 3, 23, 391, 8, 23, 1, 24, 3, 24,
		394, 8, 24, 1, 24, 1, 24, 1, 24, 3, 24, 399, 8, 24, 1, 25, 1, 25, 1, 25,
		1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 410, 8, 25, 1, 26, 1,
		26, 1, 26, 1, 26, 3, 26, 416, 8, 26, 1, 27, 1, 27, 1, 27, 3, 27, 421, 8,
		27, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 5, 29, 429, 8, 29, 10, 29,
		12, 29, 432, 9, 29, 1, 30, 1, 30, 3, 30, 436, 8, 30, 1, 30, 1, 30, 3, 30,
		440, 8, 30, 1, 30, 1, 30, 3, 30, 444, 8, 30, 1, 31, 1, 31, 1, 31, 3, 31,
		449, 8, 31, 1, 32, 1, 32, 1, 32, 5, 32, 454, 8, 32, 10, 32, 12, 32, 457,
		9, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 34, 3, 34, 464, 8, 34, 1, 34, 3,
		34, 467, 8, 34, 1, 34, 3, 34, 470, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		36, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 38,
		1, 38, 1, 38, 3, 38, 489, 8, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 503, 8, 39, 1, 40,
		1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 514, 8,
		40, 10, 40, 12, 40, 517, 9, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40,
		1, 40, 5, 40, 526, 8, 40, 10, 40, 12, 40, 529, 9, 40, 1, 40, 1, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 538, 8, 40, 10, 40, 12, 40, 541,
		9, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 548, 8, 40, 1, 40, 1,
		40, 3, 40, 552, 8, 40, 1, 41, 1, 41, 1, 41, 5, 41, 557, 8, 41, 10, 41,
		12, 41, 560, 9, 41, 1, 42, 1, 42, 1, 42, 3, 42, 565, 8, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 573, 8, 42, 1, 43, 1, 43, 1, 43, 3,
		43, 578, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 4, 43, 585, 8, 43, 11,
		43, 12, 43, 586, 1, 43, 1, 43, 3, 43, 591, 8, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 622, 8, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 3, 43, 639, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 651, 8, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 661, 8, 43, 1, 43, 3, 43, 664,
		8, 43, 1, 43, 1, 43, 3, 43, 668, 8, 43, 1, 43, 3, 43, 671, 8, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 3, 43, 688, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 3, 43, 705, 8, 43, 1, 43, 1, 43, 3, 43, 709, 8, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 3, 43, 726, 8, 43, 1, 43, 3, 43, 729, 8, 43, 1, 43, 1, 43,
		3, 43, 733, 8, 43, 1, 43, 3, 43, 736, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 747, 8, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 771,
		8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 778, 8, 43, 5, 43, 780,
		8, 43, 10, 43, 12, 43, 783, 9, 43, 1, 44, 1, 44, 1, 44, 5, 44, 788, 8,
		44, 10, 44, 12, 44, 791, 9, 44, 1, 45, 1, 45, 3, 45, 795, 8, 45, 1, 46,
		1, 46, 1, 46, 1, 46, 5, 46, 801, 8, 46, 10, 46, 12, 46, 804, 9, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 811, 8, 46, 10, 46, 12, 46, 814,
		9, 46, 3, 46, 816, 8, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 3,
		47, 824, 8, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 3, 48, 831, 8, 48, 1,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 840, 8, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 3, 49, 846, 8, 49, 5, 49, 848, 8, 49, 10, 49, 12,
		49, 851, 9, 49, 1, 50, 1, 50, 1, 50, 3, 50, 856, 8, 50, 1, 50, 1, 50, 1,
		51, 1, 51, 1, 51, 3, 51, 863, 8, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52,
		5, 52, 870, 8, 52, 10, 52, 12, 52, 873, 9, 52, 1, 53, 1, 53, 1, 53, 3,
		53, 878, 8, 53, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55,
		3, 55, 888, 8, 55, 3, 55, 890, 8, 55, 1, 56, 3, 56, 893, 8, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 901, 8, 56, 1, 57, 1, 57, 1,
		57, 3, 57, 906, 8, 57, 1, 58, 1, 58, 1, 59, 1, 59, 1, 60, 1, 60, 1, 61,
		1, 61, 3, 61, 916, 8, 61, 1, 62, 1, 62, 1, 62, 3, 62, 921, 8, 62, 1, 63,
		1, 63, 3, 63, 925, 8, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 0, 3, 44,
		86, 98, 65, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
		32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
		68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102,
		104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 0, 20,
		2, 0, 31, 31, 140, 140, 2, 0, 83, 83, 95, 95, 2, 0, 70, 70, 100, 100, 3,
		0, 4, 4, 8, 8, 12, 12, 4, 0, 4, 4, 7, 8, 12, 12, 146, 146, 2, 0, 95, 95,
		139, 139, 2, 0, 4, 4, 8, 8, 2, 0, 117, 117, 204, 204, 2, 0, 11, 11, 41,
		42, 2, 0, 61, 61, 92, 92, 2, 0, 132, 132, 142, 142, 3, 0, 17, 17, 94, 94,
		170, 170, 3, 0, 200, 200, 218, 218, 227, 227, 2, 0, 205, 206, 219, 219,
		2, 0, 78, 78, 97, 97, 1, 0, 195, 196, 2, 0, 206, 206, 219, 219, 8, 0, 36,
		36, 75, 75, 107, 107, 109, 109, 131, 131, 144, 144, 185, 185, 190, 190,
		13, 0, 2, 35, 37, 74, 76, 80, 82, 106, 108, 108, 110, 111, 113, 114, 116,
		129, 132, 143, 145, 159, 161, 184, 186, 189, 191, 192, 4, 0, 35, 35, 61,
		61, 76, 76, 90, 90, 1038, 0, 130, 1, 0, 0, 0, 2, 144, 1, 0, 0, 0, 4, 148,
		1, 0, 0, 0, 6, 157, 1, 0, 0, 0, 8, 166, 1, 0, 0, 0, 10, 177, 1, 0, 0, 0,
		12, 191, 1, 0, 0, 0, 14, 194, 1, 0, 0, 0, 16, 251, 1, 0, 0, 0, 18, 254,
		1, 0, 0, 0, 20, 260, 1, 0, 0, 0, 22, 264, 1, 0, 0, 0, 24, 270, 1, 0, 0,
		0, 26, 277, 1, 0, 0, 0, 28, 280, 1, 0, 0, 0, 30, 283, 1, 0, 0, 0, 32, 293,
		1, 0, 0, 0, 34, 296, 1, 0, 0, 0, 36, 300, 1, 0, 0, 0, 38, 305, 1, 0, 0,
		0, 40, 311, 1, 0, 0, 0, 42, 314, 1, 0, 0, 0, 44, 329, 1, 0, 0, 0, 46, 390,
		1, 0, 0, 0, 48, 398, 1, 0, 0, 0, 50, 409, 1, 0, 0, 0, 52, 411, 1, 0, 0,
		0, 54, 417, 1, 0, 0, 0, 56, 422, 1, 0, 0, 0, 58, 425, 1, 0, 0, 0, 60, 433,
		1, 0, 0, 0, 62, 445, 1, 0, 0, 0, 64, 450, 1, 0, 0, 0, 66, 458, 1, 0, 0,
		0, 68, 463, 1, 0, 0, 0, 70, 471, 1, 0, 0, 0, 72, 475, 1, 0, 0, 0, 74, 479,
		1, 0, 0, 0, 76, 488, 1, 0, 0, 0, 78, 502, 1, 0, 0, 0, 80, 551, 1, 0, 0,
		0, 82, 553, 1, 0, 0, 0, 84, 572, 1, 0, 0, 0, 86, 708, 1, 0, 0, 0, 88, 784,
		1, 0, 0, 0, 90, 794, 1, 0, 0, 0, 92, 815, 1, 0, 0, 0, 94, 823, 1, 0, 0,
		0, 96, 827, 1, 0, 0, 0, 98, 839, 1, 0, 0, 0, 100, 852, 1, 0, 0, 0, 102,
		862, 1, 0, 0, 0, 104, 866, 1, 0, 0, 0, 106, 877, 1, 0, 0, 0, 108, 879,
		1, 0, 0, 0, 110, 889, 1, 0, 0, 0, 112, 892, 1, 0, 0, 0, 114, 905, 1, 0,
		0, 0, 116, 907, 1, 0, 0, 0, 118, 909, 1, 0, 0, 0, 120, 911, 1, 0, 0, 0,
		122, 915, 1, 0, 0, 0, 124, 920, 1, 0, 0, 0, 126, 924, 1, 0, 0, 0, 128,
		926, 1, 0, 0, 0, 130, 134, 3, 2, 1, 0, 131, 132, 5, 86, 0, 0, 132, 133,
		5, 123, 0, 0, 133, 135, 5, 198, 0, 0, 134, 131, 1, 0, 0, 0, 134, 135, 1,
		0, 0, 0, 135, 138, 1, 0, 0, 0, 136, 137, 5, 65, 0, 0, 137, 139, 3, 126,
		63, 0, 138, 136, 1, 0, 0, 0, 138, 139, 1, 0, 0, 0, 139, 141, 1, 0, 0, 0,
		140, 142, 5, 226, 0, 0, 141, 140, 1, 0, 0, 0, 141, 142, 1, 0, 0, 0, 142,
		1, 1, 0, 0, 0, 143, 145, 3, 4, 2, 0, 144, 143, 1, 0, 0, 0, 144, 145, 1,
		0, 0, 0, 145, 146, 1, 0, 0, 0, 146, 147, 3, 14, 7, 0, 147, 3, 1, 0, 0,
		0, 148, 149, 5, 189, 0, 0, 149, 154, 3, 6, 3, 0, 150, 151, 5, 204, 0, 0,
		151, 153, 3, 6, 3, 0, 152, 150, 1, 0, 0, 0, 153, 156, 1, 0, 0, 0, 154,
		152, 1, 0, 0, 0, 154, 155, 1, 0, 0, 0, 155, 5, 1, 0, 0, 0, 156, 154, 1,
		0, 0, 0, 157, 159, 3, 124, 62, 0, 158, 160, 3, 8, 4, 0, 159, 158, 1, 0,
		0, 0, 159, 160, 1, 0, 0, 0, 160, 161, 1, 0, 0, 0, 161, 162, 5, 10, 0, 0,
		162, 163, 5, 215, 0, 0, 163, 164, 3, 2, 1, 0, 164, 165, 5, 225, 0, 0, 165,
		7, 1, 0, 0, 0, 166, 167, 5, 215, 0, 0, 167, 172, 3, 124, 62, 0, 168, 169,
		5, 204, 0, 0, 169, 171, 3, 124, 62, 0, 170, 168, 1, 0, 0, 0, 171, 174,
		1, 0, 0, 0, 172, 170, 1, 0, 0, 0, 172, 173, 1, 0, 0, 0, 173, 175, 1, 0,
		0, 0, 174, 172, 1, 0, 0, 0, 175, 176, 5, 225, 0, 0, 176, 9, 1, 0, 0, 0,
		177, 183, 3, 12, 6, 0, 178, 179, 5, 176, 0, 0, 179, 180, 5, 4, 0, 0, 180,
		182, 3, 12, 6, 0, 181, 178, 1, 0, 0, 0, 182, 185, 1, 0, 0, 0, 183, 181,
		1, 0, 0, 0, 183, 184, 1, 0, 0, 0, 184, 11, 1, 0, 0, 0, 185, 183, 1, 0,
		0, 0, 186, 192, 3, 14, 7, 0, 187, 188, 5, 215, 0, 0, 188, 189, 3, 10, 5,
		0, 189, 190, 5, 225, 0, 0, 190, 192, 1, 0, 0, 0, 191, 186, 1, 0, 0, 0,
		191, 187, 1, 0, 0, 0, 192, 13, 1, 0, 0, 0, 193, 195, 3, 16, 8, 0, 194,
		193, 1, 0, 0, 0, 194, 195, 1, 0, 0, 0, 195, 196, 1, 0, 0, 0, 196, 198,
		5, 145, 0, 0, 197, 199, 5, 48, 0, 0, 198, 197, 1, 0, 0, 0, 198, 199, 1,
		0, 0, 0, 199, 201, 1, 0, 0, 0, 200, 202, 3, 18, 9, 0, 201, 200, 1, 0, 0,
		0, 201, 202, 1, 0, 0, 0, 202, 203, 1, 0, 0, 0, 203, 205, 3, 82, 41, 0,
		204, 206, 5, 204, 0, 0, 205, 204, 1, 0, 0, 0, 205, 206, 1, 0, 0, 0, 206,
		208, 1, 0, 0, 0, 207, 209, 3, 20, 10, 0, 208, 207, 1, 0, 0, 0, 208, 209,
		1, 0, 0, 0, 209, 211, 1, 0, 0, 0, 210, 212, 3, 22, 11, 0, 211, 210, 1,
		0, 0, 0, 211, 212, 1, 0, 0, 0, 212, 214, 1, 0, 0, 0, 213, 215, 3, 24, 12,
		0, 214, 213, 1, 0, 0, 0, 214, 215, 1, 0, 0, 0, 215, 217, 1, 0, 0, 0, 216,
		218, 3, 26, 13, 0, 217, 216, 1, 0, 0, 0, 217, 218, 1, 0, 0, 0, 218, 220,
		1, 0, 0, 0, 219, 221, 3, 28, 14, 0, 220, 219, 1, 0, 0, 0, 220, 221, 1,
		0, 0, 0, 221, 223, 1, 0, 0, 0, 222, 224, 3, 30, 15, 0, 223, 222, 1, 0,
		0, 0, 223, 224, 1, 0, 0, 0, 224, 227, 1, 0, 0, 0, 225, 226, 5, 189, 0,
		0, 226, 228, 7, 0, 0, 0, 227, 225, 1, 0, 0, 0, 227, 228, 1, 0, 0, 0, 228,
		231, 1, 0, 0, 0, 229, 230, 5, 189, 0, 0, 230, 232, 5, 169, 0, 0, 231, 229,
		1, 0, 0, 0, 231, 232, 1, 0, 0, 0, 232, 234, 1, 0, 0, 0, 233, 235, 3, 32,
		16, 0, 234, 233, 1, 0, 0, 0, 234, 235, 1, 0, 0, 0, 235, 237, 1, 0, 0, 0,
		236, 238, 3, 34, 17, 0, 237, 236, 1, 0, 0, 0, 237, 238, 1, 0, 0, 0, 238,
		240, 1, 0, 0, 0, 239, 241, 3, 36, 18, 0, 240, 239, 1, 0, 0, 0, 240, 241,
		1, 0, 0, 0, 241, 243, 1, 0, 0, 0, 242, 244, 3, 38, 19, 0, 243, 242, 1,
		0, 0, 0, 243, 244, 1, 0, 0, 0, 244, 246, 1, 0, 0, 0, 245, 247, 3, 40, 20,
		0, 246, 245, 1, 0, 0, 0, 246, 247, 1, 0, 0, 0, 247, 249, 1, 0, 0, 0, 248,
		250, 3, 42, 21, 0, 249, 248, 1, 0, 0, 0, 249, 250, 1, 0, 0, 0, 250, 15,
		1, 0, 0, 0, 251, 252, 5, 189, 0, 0, 252, 253, 3, 82, 41, 0, 253, 17, 1,
		0, 0, 0, 254, 255, 5, 168, 0, 0, 255, 258, 5, 196, 0, 0, 256, 257, 5, 189,
		0, 0, 257, 259, 5, 164, 0, 0, 258, 256, 1, 0, 0, 0, 258, 259, 1, 0, 0,
		0, 259, 19, 1, 0, 0, 0, 260, 261, 5, 67, 0, 0, 261, 262, 3, 44, 22, 0,
		262, 21, 1, 0, 0, 0, 263, 265, 7, 1, 0, 0, 264, 263, 1, 0, 0, 0, 264, 265,
		1, 0, 0, 0, 265, 266, 1, 0, 0, 0, 266, 267, 5, 9, 0, 0, 267, 268, 5, 89,
		0, 0, 268, 269, 3, 82, 41, 0, 269, 23, 1, 0, 0, 0, 270, 271, 5, 188, 0,
		0, 271, 272, 3, 124, 62, 0, 272, 273, 5, 10, 0, 0, 273, 274, 5, 215, 0,
		0, 274, 275, 3, 68, 34, 0, 275, 276, 5, 225, 0, 0, 276, 25, 1, 0, 0, 0,
		277, 278, 5, 128, 0, 0, 278, 279, 3, 86, 43, 0, 279, 27, 1, 0, 0, 0, 280,
		281, 5, 187, 0, 0, 281, 282, 3, 86, 43, 0, 282, 29, 1, 0, 0, 0, 283, 284,
		5, 72, 0, 0, 284, 291, 5, 18, 0, 0, 285, 286, 7, 0, 0, 0, 286, 287, 5,
		215, 0, 0, 287, 288, 3, 82, 41, 0, 288, 289, 5, 225, 0, 0, 289, 292, 1,
		0, 0, 0, 290, 292, 3, 82, 41, 0, 291, 285, 1, 0, 0, 0, 291, 290, 1, 0,
		0, 0, 292, 31, 1, 0, 0, 0, 293, 294, 5, 73, 0, 0, 294, 295, 3, 86, 43,
		0, 295, 33, 1, 0, 0, 0, 296, 297, 5, 121, 0, 0, 297, 298, 5, 18, 0, 0,
		298, 299, 3, 58, 29, 0, 299, 35, 1, 0, 0, 0, 300, 301, 5, 98, 0, 0, 301,
		302, 3, 54, 27, 0, 302, 303, 5, 18, 0, 0, 303, 304, 3, 82, 41, 0, 304,
		37, 1, 0, 0, 0, 305, 306, 5, 98, 0, 0, 306, 309, 3, 54, 27, 0, 307, 308,
		5, 189, 0, 0, 308, 310, 5, 164, 0, 0, 309, 307, 1, 0, 0, 0, 309, 310, 1,
		0, 0, 0, 310, 39, 1, 0, 0, 0, 311, 312, 5, 160, 0, 0, 312, 313, 3, 56,
		28, 0, 313, 41, 1, 0, 0, 0, 314, 315, 5, 149, 0, 0, 315, 316, 3, 64, 32,
		0, 316, 43, 1, 0, 0, 0, 317, 318, 6, 22, -1, 0, 318, 320, 3, 98, 49, 0,
		319, 321, 5, 60, 0, 0, 320, 319, 1, 0, 0, 0, 320, 321, 1, 0, 0, 0, 321,
		323, 1, 0, 0, 0, 322, 324, 3, 52, 26, 0, 323, 322, 1, 0, 0, 0, 323, 324,
		1, 0, 0, 0, 324, 330, 1, 0, 0, 0, 325, 326, 5, 215, 0, 0, 326, 327, 3,
		44, 22, 0, 327, 328, 5, 225, 0, 0, 328, 330, 1, 0, 0, 0, 329, 317, 1, 0,
		0, 0, 329, 325, 1, 0, 0, 0, 330, 344, 1, 0, 0, 0, 331, 333, 10, 3, 0, 0,
		332, 334, 7, 2, 0, 0, 333, 332, 1, 0, 0, 0, 333, 334, 1, 0, 0, 0, 334,
		336, 1, 0, 0, 0, 335, 337, 3, 46, 23, 0, 336, 335, 1, 0, 0, 0, 336, 337,
		1, 0, 0, 0, 337, 338, 1, 0, 0, 0, 338, 339, 5, 89, 0, 0, 339, 340, 3, 44,
		22, 0, 340, 341, 3, 50, 25, 0, 341, 343, 1, 0, 0, 0, 342, 331, 1, 0, 0,
		0, 343, 346, 1, 0, 0, 0, 344, 342, 1, 0, 0, 0, 344, 345, 1, 0, 0, 0, 345,
		45, 1, 0, 0, 0, 346, 344, 1, 0, 0, 0, 347, 349, 7, 3, 0, 0, 348, 347, 1,
		0, 0, 0, 348, 349, 1, 0, 0, 0, 349, 350, 1, 0, 0, 0, 350, 357, 5, 83, 0,
		0, 351, 353, 5, 83, 0, 0, 352, 354, 7, 3, 0, 0, 353, 352, 1, 0, 0, 0, 353,
		354, 1, 0, 0, 0, 354, 357, 1, 0, 0, 0, 355, 357, 7, 3, 0, 0, 356, 348,
		1, 0, 0, 0, 356, 351, 1, 0, 0, 0, 356, 355, 1, 0, 0, 0, 357, 391, 1, 0,
		0, 0, 358, 360, 7, 4, 0, 0, 359, 358, 1, 0, 0, 0, 359, 360, 1, 0, 0, 0,
		360, 361, 1, 0, 0, 0, 361, 363, 7, 5, 0, 0, 362, 364, 5, 122, 0, 0, 363,
		362, 1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364, 373, 1, 0, 0, 0, 365, 367,
		7, 5, 0, 0, 366, 368, 5, 122, 0, 0, 367, 366, 1, 0, 0, 0, 367, 368, 1,
		0, 0, 0, 368, 370, 1, 0, 0, 0, 369, 371, 7, 4, 0, 0, 370, 369, 1, 0, 0,
		0, 370, 371, 1, 0, 0, 0, 371, 373, 1, 0, 0, 0, 372, 359, 1, 0, 0, 0, 372,
		365, 1, 0, 0, 0, 373, 391, 1, 0, 0, 0, 374, 376, 7, 6, 0, 0, 375, 374,
		1, 0, 0, 0, 375, 376, 1, 0, 0, 0, 376, 377, 1, 0, 0, 0, 377, 379, 5, 68,
		0, 0, 378, 380, 5, 122, 0, 0, 379, 378, 1, 0, 0, 0, 379, 380, 1, 0, 0,
		0, 380, 389, 1, 0, 0, 0, 381, 383, 5, 68, 0, 0, 382, 384, 5, 122, 0, 0,
		383, 382, 1, 0, 0, 0, 383, 384, 1, 0, 0, 0, 384, 386, 1, 0, 0, 0, 385,
		387, 7, 6, 0, 0, 386, 385, 1, 0, 0, 0, 386, 387, 1, 0, 0, 0, 387, 389,
		1, 0, 0, 0, 388, 375, 1, 0, 0, 0, 388, 381, 1, 0, 0, 0, 389, 391, 1, 0,
		0, 0, 390, 356, 1, 0, 0, 0, 390, 372, 1, 0, 0, 0, 390, 388, 1, 0, 0, 0,
		391, 47, 1, 0, 0, 0, 392, 394, 7, 2, 0, 0, 393, 392, 1, 0, 0, 0, 393, 394,
		1, 0, 0, 0, 394, 395, 1, 0, 0, 0, 395, 396, 5, 30, 0, 0, 396, 399, 5, 89,
		0, 0, 397, 399, 5, 204, 0, 0, 398, 393, 1, 0, 0, 0, 398, 397, 1, 0, 0,
		0, 399, 49, 1, 0, 0, 0, 400, 401, 5, 118, 0, 0, 401, 410, 3, 82, 41, 0,
		402, 403, 5, 179, 0, 0, 403, 404, 5, 215, 0, 0, 404, 405, 3, 82, 41, 0,
		405, 406, 5, 225, 0, 0, 406, 410, 1, 0, 0, 0, 407, 408, 5, 179, 0, 0, 408,
		410, 3, 82, 41, 0, 409, 400, 1, 0, 0, 0, 409, 402, 1, 0, 0, 0, 409, 407,
		1, 0, 0, 0, 410, 51, 1, 0, 0, 0, 411, 412, 5, 143, 0, 0, 412, 415, 3, 62,
		31, 0, 413, 414, 5, 117, 0, 0, 414, 416, 3, 62, 31, 0, 415, 413, 1, 0,
		0, 0, 415, 416, 1, 0, 0, 0, 416, 53, 1, 0, 0, 0, 417, 420, 3, 86, 43, 0,
		418, 419, 7, 7, 0, 0, 419, 421, 3, 86, 43, 0, 420, 418, 1, 0, 0, 0, 420,
		421, 1, 0, 0, 0, 421, 55, 1, 0, 0, 0, 422, 423, 3, 112, 56, 0, 423, 424,
		5, 72, 0, 0, 424, 57, 1, 0, 0, 0, 425, 430, 3, 60, 30, 0, 426, 427, 5,
		204, 0, 0, 427, 429, 3, 60, 30, 0, 428, 426, 1, 0, 0, 0, 429, 432, 1, 0,
		0, 0, 430, 428, 1, 0, 0, 0, 430, 431, 1, 0, 0, 0, 431, 59, 1, 0, 0, 0,
		432, 430, 1, 0, 0, 0, 433, 435, 3, 86, 43, 0, 434, 436, 7, 8, 0, 0, 435,
		434, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 439, 1, 0, 0, 0, 437, 438,
		5, 116, 0, 0, 438, 440, 7, 9, 0, 0, 439, 437, 1, 0, 0, 0, 439, 440, 1,
		0, 0, 0, 440, 443, 1, 0, 0, 0, 441, 442, 5, 25, 0, 0, 442, 444, 5, 198,
		0, 0, 443, 441, 1, 0, 0, 0, 443, 444, 1, 0, 0, 0, 444, 61, 1, 0, 0, 0,
		445, 448, 3, 112, 56, 0, 446, 447, 5, 227, 0, 0, 447, 449, 3, 112, 56,
		0, 448, 446, 1, 0, 0, 0, 448, 449, 1, 0, 0, 0, 449, 63, 1, 0, 0, 0, 450,
		455, 3, 66, 33, 0, 451, 452, 5, 204, 0, 0, 452, 454, 3, 66, 33, 0, 453,
		451, 1, 0, 0, 0, 454, 457, 1, 0, 0, 0, 455, 453, 1, 0, 0, 0, 455, 456,
		1, 0, 0, 0, 456, 65, 1, 0, 0, 0, 457, 455, 1, 0, 0, 0, 458, 459, 3, 124,
		62, 0, 459, 460, 5, 209, 0, 0, 460, 461, 3, 114, 57, 0, 461, 67, 1, 0,
		0, 0, 462, 464, 3, 70, 35, 0, 463, 462, 1, 0, 0, 0, 463, 464, 1, 0, 0,
		0, 464, 466, 1, 0, 0, 0, 465, 467, 3, 72, 36, 0, 466, 465, 1, 0, 0, 0,
		466, 467, 1, 0, 0, 0, 467, 469, 1, 0, 0, 0, 468, 470, 3, 74, 37, 0, 469,
		468, 1, 0, 0, 0, 469, 470, 1, 0, 0, 0, 470, 69, 1, 0, 0, 0, 471, 472, 5,
		125, 0, 0, 472, 473, 5, 18, 0, 0, 473, 474, 3, 82, 41, 0, 474, 71, 1, 0,
		0, 0, 475, 476, 5, 121, 0, 0, 476, 477, 5, 18, 0, 0, 477, 478, 3, 58, 29,
		0, 478, 73, 1, 0, 0, 0, 479, 480, 7, 10, 0, 0, 480, 481, 3, 76, 38, 0,
		481, 75, 1, 0, 0, 0, 482, 489, 3, 78, 39, 0, 483, 484, 5, 16, 0, 0, 484,
		485, 3, 78, 39, 0, 485, 486, 5, 6, 0, 0, 486, 487, 3, 78, 39, 0, 487, 489,
		1, 0, 0, 0, 488, 482, 1, 0, 0, 0, 488, 483, 1, 0, 0, 0, 489, 77, 1, 0,
		0, 0, 490, 491, 5, 32, 0, 0, 491, 503, 5, 141, 0, 0, 492, 493, 5, 175,
		0, 0, 493, 503, 5, 127, 0, 0, 494, 495, 5, 175, 0, 0, 495, 503, 5, 63,
		0, 0, 496, 497, 3, 112, 56, 0, 497, 498, 5, 127, 0, 0, 498, 503, 1, 0,
		0, 0, 499, 500, 3, 112, 56, 0, 500, 501, 5, 63, 0, 0, 501, 503, 1, 0, 0,
		0, 502, 490, 1, 0, 0, 0, 502, 492, 1, 0, 0, 0, 502, 494, 1, 0, 0, 0, 502,
		496, 1, 0, 0, 0, 502, 499, 1, 0, 0, 0, 503, 79, 1, 0, 0, 0, 504, 552, 3,
		124, 62, 0, 505, 506, 3, 124, 62, 0, 506, 507, 5, 215, 0, 0, 507, 508,
		3, 124, 62, 0, 508, 515, 3, 80, 40, 0, 509, 510, 5, 204, 0, 0, 510, 511,
		3, 124, 62, 0, 511, 512, 3, 80, 40, 0, 512, 514, 1, 0, 0, 0, 513, 509,
		1, 0, 0, 0, 514, 517, 1, 0, 0, 0, 515, 513, 1, 0, 0, 0, 515, 516, 1, 0,
		0, 0, 516, 518, 1, 0, 0, 0, 517, 515, 1, 0, 0, 0, 518, 519, 5, 225, 0,
		0, 519, 552, 1, 0, 0, 0, 520, 521, 3, 124, 62, 0, 521, 522, 5, 215, 0,
		0, 522, 527, 3, 128, 64, 0, 523, 524, 5, 204, 0, 0, 524, 526, 3, 128, 64,
		0, 525, 523, 1, 0, 0, 0, 526, 529, 1, 0, 0, 0, 527, 525, 1, 0, 0, 0, 527,
		528, 1, 0, 0, 0, 528, 530, 1, 0, 0, 0, 529, 527, 1, 0, 0, 0, 530, 531,
		5, 225, 0, 0, 531, 552, 1, 0, 0, 0, 532, 533, 3, 124, 62, 0, 533, 534,
		5, 215, 0, 0, 534, 539, 3, 80, 40, 0, 535, 536, 5, 204, 0, 0, 536, 538,
		3, 80, 40, 0, 537, 535, 1, 0, 0, 0, 538, 541, 1, 0, 0, 0, 539, 537, 1,
		0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 542, 1, 0, 0, 0, 541, 539, 1, 0, 0,
		0, 542, 543, 5, 225, 0, 0, 543, 552, 1, 0, 0, 0, 544, 545, 3, 124, 62,
		0, 545, 547, 5, 215, 0, 0, 546, 548, 3, 82, 41, 0, 547, 546, 1, 0, 0, 0,
		547, 548, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549, 550, 5, 225, 0, 0, 550,
		552, 1, 0, 0, 0, 551, 504, 1, 0, 0, 0, 551, 505, 1, 0, 0, 0, 551, 520,
		1, 0, 0, 0, 551, 532, 1, 0, 0, 0, 551, 544, 1, 0, 0, 0, 552, 81, 1, 0,
		0, 0, 553, 558, 3, 84, 42, 0, 554, 555, 5, 204, 0, 0, 555, 557, 3, 84,
		42, 0, 556, 554, 1, 0, 0, 0, 557, 560, 1, 0, 0, 0, 558, 556, 1, 0, 0, 0,
		558, 559, 1, 0, 0, 0, 559, 83, 1, 0, 0, 0, 560, 558, 1, 0, 0, 0, 561, 562,
		3, 102, 51, 0, 562, 563, 5, 207, 0, 0, 563, 565, 1, 0, 0, 0, 564, 561,
		1, 0, 0, 0, 564, 565, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 573, 5, 200,
		0, 0, 567, 568, 5, 215, 0, 0, 568, 569, 3, 10, 5, 0, 569, 570, 5, 225,
		0, 0, 570, 573, 1, 0, 0, 0, 571, 573, 3, 86, 43, 0, 572, 564, 1, 0, 0,
		0, 572, 567, 1, 0, 0, 0, 572, 571, 1, 0, 0, 0, 573, 85, 1, 0, 0, 0, 574,
		575, 6, 43, -1, 0, 575, 577, 5, 19, 0, 0, 576, 578, 3, 86, 43, 0, 577,
		576, 1, 0, 0, 0, 577, 578, 1, 0, 0, 0, 578, 584, 1, 0, 0, 0, 579, 580,
		5, 186, 0, 0, 580, 581, 3, 86, 43, 0, 581, 582, 5, 163, 0, 0, 582, 583,
		3, 86, 43, 0, 583, 585, 1, 0, 0, 0, 584, 579, 1, 0, 0, 0, 585, 586, 1,
		0, 0, 0, 586, 584, 1, 0, 0, 0, 586, 587, 1, 0, 0, 0, 587, 590, 1, 0, 0,
		0, 588, 589, 5, 51, 0, 0, 589, 591, 3, 86, 43, 0, 590, 588, 1, 0, 0, 0,
		590, 591, 1, 0, 0, 0, 591, 592, 1, 0, 0, 0, 592, 593, 5, 52, 0, 0, 593,
		709, 1, 0, 0, 0, 594, 595, 5, 20, 0, 0, 595, 596, 5, 215, 0, 0, 596, 597,
		3, 86, 43, 0, 597, 598, 5, 10, 0, 0, 598, 599, 3, 80, 40, 0, 599, 600,
		5, 225, 0, 0, 600, 709, 1, 0, 0, 0, 601, 602, 5, 35, 0, 0, 602, 709, 5,
		198, 0, 0, 603, 604, 5, 58, 0, 0, 604, 605, 5, 215, 0, 0, 605, 606, 3,
		116, 58, 0, 606, 607, 5, 67, 0, 0, 607, 608, 3, 86, 43, 0, 608, 609, 5,
		225, 0, 0, 609, 709, 1, 0, 0, 0, 610, 611, 5, 85, 0, 0, 611, 612, 3, 86,
		43, 0, 612, 613, 3, 116, 58, 0, 613, 709, 1, 0, 0, 0, 614, 615, 5, 154,
		0, 0, 615, 616, 5, 215, 0, 0, 616, 617, 3, 86, 43, 0, 617, 618, 5, 67,
		0, 0, 618, 621, 3, 86, 43, 0, 619, 620, 5, 64, 0, 0, 620, 622, 3, 86, 43,
		0, 621, 619, 1, 0, 0, 0, 621, 622, 1, 0, 0, 0, 622, 623, 1, 0, 0, 0, 623,
		624, 5, 225, 0, 0, 624, 709, 1, 0, 0, 0, 625, 626, 5, 166, 0, 0, 626, 709,
		5, 198, 0, 0, 627, 628, 5, 171, 0, 0, 628, 629, 5, 215, 0, 0, 629, 630,
		7, 11, 0, 0, 630, 631, 5, 198, 0, 0, 631, 632, 5, 67, 0, 0, 632, 633, 3,
		86, 43, 0, 633, 634, 5, 225, 0, 0, 634, 709, 1, 0, 0, 0, 635, 636, 3, 124,
		62, 0, 636, 638, 5, 215, 0, 0, 637, 639, 3, 82, 41, 0, 638, 637, 1, 0,
		0, 0, 638, 639, 1, 0, 0, 0, 639, 640, 1, 0, 0, 0, 640, 641, 5, 225, 0,
		0, 641, 642, 1, 0, 0, 0, 642, 643, 5, 124, 0, 0, 643, 644, 5, 215, 0, 0,
		644, 645, 3, 68, 34, 0, 645, 646, 5, 225, 0, 0, 646, 709, 1, 0, 0, 0, 647,
		648, 3, 124, 62, 0, 648, 650, 5, 215, 0, 0, 649, 651, 3, 82, 41, 0, 650,
		649, 1, 0, 0, 0, 650, 651, 1, 0, 0, 0, 651, 652, 1, 0, 0, 0, 652, 653,
		5, 225, 0, 0, 653, 654, 1, 0, 0, 0, 654, 655, 5, 124, 0, 0, 655, 656, 3,
		124, 62, 0, 656, 709, 1, 0, 0, 0, 657, 663, 3, 124, 62, 0, 658, 660, 5,
		215, 0, 0, 659, 661, 3, 82, 41, 0, 660, 659, 1, 0, 0, 0, 660, 661, 1, 0,
		0, 0, 661, 662, 1, 0, 0, 0, 662, 664, 5, 225, 0, 0, 663, 658, 1, 0, 0,
		0, 663, 664, 1, 0, 0, 0, 664, 665, 1, 0, 0, 0, 665, 667, 5, 215, 0, 0,
		666, 668, 5, 48, 0, 0, 667, 666, 1, 0, 0, 0, 667, 668, 1, 0, 0, 0, 668,
		670, 1, 0, 0, 0, 669, 671, 3, 88, 44, 0, 670, 669, 1, 0, 0, 0, 670, 671,
		1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 673, 5, 225, 0, 0, 673, 709, 1,
		0, 0, 0, 674, 709, 3, 114, 57, 0, 675, 676, 5, 193, 0, 0, 676, 677, 5,
		212, 0, 0, 677, 678, 3, 114, 57, 0, 678, 679, 5, 223, 0, 0, 679, 709, 1,
		0, 0, 0, 680, 681, 5, 206, 0, 0, 681, 709, 3, 86, 43, 17, 682, 683, 5,
		114, 0, 0, 683, 709, 3, 86, 43, 12, 684, 685, 3, 102, 51, 0, 685, 686,
		5, 207, 0, 0, 686, 688, 1, 0, 0, 0, 687, 684, 1, 0, 0, 0, 687, 688, 1,
		0, 0, 0, 688, 689, 1, 0, 0, 0, 689, 709, 5, 200, 0, 0, 690, 691, 5, 215,
		0, 0, 691, 692, 3, 10, 5, 0, 692, 693, 5, 225, 0, 0, 693, 709, 1, 0, 0,
		0, 694, 695, 5, 215, 0, 0, 695, 696, 3, 86, 43, 0, 696, 697, 5, 225, 0,
		0, 697, 709, 1, 0, 0, 0, 698, 699, 5, 215, 0, 0, 699, 700, 3, 82, 41, 0,
		700, 701, 5, 225, 0, 0, 701, 709, 1, 0, 0, 0, 702, 704, 5, 213, 0, 0, 703,
		705, 3, 82, 41, 0, 704, 703, 1, 0, 0, 0, 704, 705, 1, 0, 0, 0, 705, 706,
		1, 0, 0, 0, 706, 709, 5, 224, 0, 0, 707, 709, 3, 94, 47, 0, 708, 574, 1,
		0, 0, 0, 708, 594, 1, 0, 0, 0, 708, 601, 1, 0, 0, 0, 708, 603, 1, 0, 0,
		0, 708, 610, 1, 0, 0, 0, 708, 614, 1, 0, 0, 0, 708, 625, 1, 0, 0, 0, 708,
		627, 1, 0, 0, 0, 708, 635, 1, 0, 0, 0, 708, 647, 1, 0, 0, 0, 708, 657,
		1, 0, 0, 0, 708, 674, 1, 0, 0, 0, 708, 675, 1, 0, 0, 0, 708, 680, 1, 0,
		0, 0, 708, 682, 1, 0, 0, 0, 708, 687, 1, 0, 0, 0, 708, 690, 1, 0, 0, 0,
		708, 694, 1, 0, 0, 0, 708, 698, 1, 0, 0, 0, 708, 702, 1, 0, 0, 0, 708,
		707, 1, 0, 0, 0, 709, 781, 1, 0, 0, 0, 710, 711, 10, 16, 0, 0, 711, 712,
		7, 12, 0, 0, 712, 780, 3, 86, 43, 17, 713, 714, 10, 15, 0, 0, 714, 715,
		7, 13, 0, 0, 715, 780, 3, 86, 43, 16, 716, 735, 10, 14, 0, 0, 717, 736,
		5, 208, 0, 0, 718, 736, 5, 209, 0, 0, 719, 736, 5, 217, 0, 0, 720, 736,
		5, 214, 0, 0, 721, 736, 5, 210, 0, 0, 722, 736, 5, 216, 0, 0, 723, 736,
		5, 211, 0, 0, 724, 726, 5, 70, 0, 0, 725, 724, 1, 0, 0, 0, 725, 726, 1,
		0, 0, 0, 726, 728, 1, 0, 0, 0, 727, 729, 5, 114, 0, 0, 728, 727, 1, 0,
		0, 0, 728, 729, 1, 0, 0, 0, 729, 730, 1, 0, 0, 0, 730, 736, 5, 79, 0, 0,
		731, 733, 5, 114, 0, 0, 732, 731, 1, 0, 0, 0, 732, 733, 1, 0, 0, 0, 733,
		734, 1, 0, 0, 0, 734, 736, 7, 14, 0, 0, 735, 717, 1, 0, 0, 0, 735, 718,
		1, 0, 0, 0, 735, 719, 1, 0, 0, 0, 735, 720, 1, 0, 0, 0, 735, 721, 1, 0,
		0, 0, 735, 722, 1, 0, 0, 0, 735, 723, 1, 0, 0, 0, 735, 725, 1, 0, 0, 0,
		735, 732, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 780, 3, 86, 43, 15, 738,
		739, 10, 11, 0, 0, 739, 740, 5, 6, 0, 0, 740, 780, 3, 86, 43, 12, 741,
		742, 10, 10, 0, 0, 742, 743, 5, 120, 0, 0, 743, 780, 3, 86, 43, 11, 744,
		746, 10, 9, 0, 0, 745, 747, 5, 114, 0, 0, 746, 745, 1, 0, 0, 0, 746, 747,
		1, 0, 0, 0, 747, 748, 1, 0, 0, 0, 748, 749, 5, 16, 0, 0, 749, 750, 3, 86,
		43, 0, 750, 751, 5, 6, 0, 0, 751, 752, 3, 86, 43, 10, 752, 780, 1, 0, 0,
		0, 753, 754, 10, 8, 0, 0, 754, 755, 5, 220, 0, 0, 755, 756, 3, 86, 43,
		0, 756, 757, 5, 203, 0, 0, 757, 758, 3, 86, 43, 8, 758, 780, 1, 0, 0, 0,
		759, 760, 10, 19, 0, 0, 760, 761, 5, 213, 0, 0, 761, 762, 3, 86, 43, 0,
		762, 763, 5, 224, 0, 0, 763, 780, 1, 0, 0, 0, 764, 765, 10, 18, 0, 0, 765,
		766, 5, 207, 0, 0, 766, 780, 5, 196, 0, 0, 767, 768, 10, 13, 0, 0, 768,
		770, 5, 87, 0, 0, 769, 771, 5, 114, 0, 0, 770, 769, 1, 0, 0, 0, 770, 771,
		1, 0, 0, 0, 771, 772, 1, 0, 0, 0, 772, 780, 5, 115, 0, 0, 773, 777, 10,
		7, 0, 0, 774, 778, 3, 122, 61, 0, 775, 776, 5, 10, 0, 0, 776, 778, 3, 124,
		62, 0, 777, 774, 1, 0, 0, 0, 777, 775, 1, 0, 0, 0, 778, 780, 1, 0, 0, 0,
		779, 710, 1, 0, 0, 0, 779, 713, 1, 0, 0, 0, 779, 716, 1, 0, 0, 0, 779,
		738, 1, 0, 0, 0, 779, 741, 1, 0, 0, 0, 779, 744, 1, 0, 0, 0, 779, 753,
		1, 0, 0, 0, 779, 759, 1, 0, 0, 0, 779, 764, 1, 0, 0, 0, 779, 767, 1, 0,
		0, 0, 779, 773, 1, 0, 0, 0, 780, 783, 1, 0, 0, 0, 781, 779, 1, 0, 0, 0,
		781, 782, 1, 0, 0, 0, 782, 87, 1, 0, 0, 0, 783, 781, 1, 0, 0, 0, 784, 789,
		3, 90, 45, 0, 785, 786, 5, 204, 0, 0, 786, 788, 3, 90, 45, 0, 787, 785,
		1, 0, 0, 0, 788, 791, 1, 0, 0, 0, 789, 787, 1, 0, 0, 0, 789, 790, 1, 0,
		0, 0, 790, 89, 1, 0, 0, 0, 791, 789, 1, 0, 0, 0, 792, 795, 3, 92, 46, 0,
		793, 795, 3, 86, 43, 0, 794, 792, 1, 0, 0, 0, 794, 793, 1, 0, 0, 0, 795,
		91, 1, 0, 0, 0, 796, 797, 5, 215, 0, 0, 797, 802, 3, 124, 62, 0, 798, 799,
		5, 204, 0, 0, 799, 801, 3, 124, 62, 0, 800, 798, 1, 0, 0, 0, 801, 804,
		1, 0, 0, 0, 802, 800, 1, 0, 0, 0, 802, 803, 1, 0, 0, 0, 803, 805, 1, 0,
		0, 0, 804, 802, 1, 0, 0, 0, 805, 806, 5, 225, 0, 0, 806, 816, 1, 0, 0,
		0, 807, 812, 3, 124, 62, 0, 808, 809, 5, 204, 0, 0, 809, 811, 3, 124, 62,
		0, 810, 808, 1, 0, 0, 0, 811, 814, 1, 0, 0, 0, 812, 810, 1, 0, 0, 0, 812,
		813, 1, 0, 0, 0, 813, 816, 1, 0, 0, 0, 814, 812, 1, 0, 0, 0, 815, 796,
		1, 0, 0, 0, 815, 807, 1, 0, 0, 0, 816, 817, 1, 0, 0, 0, 817, 818, 5, 199,
		0, 0, 818, 819, 3, 86, 43, 0, 819, 93, 1, 0, 0, 0, 820, 821, 3, 102, 51,
		0, 821, 822, 5, 207, 0, 0, 822, 824, 1, 0, 0, 0, 823, 820, 1, 0, 0, 0,
		823, 824, 1, 0, 0, 0, 824, 825, 1, 0, 0, 0, 825, 826, 3, 96, 48, 0, 826,
		95, 1, 0, 0, 0, 827, 830, 3, 124, 62, 0, 828, 829, 5, 207, 0, 0, 829, 831,
		3, 124, 62, 0, 830, 828, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 831, 97, 1,
		0, 0, 0, 832, 833, 6, 49, -1, 0, 833, 840, 3, 102, 51, 0, 834, 840, 3,
		100, 50, 0, 835, 836, 5, 215, 0, 0, 836, 837, 3, 10, 5, 0, 837, 838, 5,
		225, 0, 0, 838, 840, 1, 0, 0, 0, 839, 832, 1, 0, 0, 0, 839, 834, 1, 0,
		0, 0, 839, 835, 1, 0, 0, 0, 840, 849, 1, 0, 0, 0, 841, 845, 10, 1, 0, 0,
		842, 846, 3, 122, 61, 0, 843, 844, 5, 10, 0, 0, 844, 846, 3, 124, 62, 0,
		845, 842, 1, 0, 0, 0, 845, 843, 1, 0, 0, 0, 846, 848, 1, 0, 0, 0, 847,
		841, 1, 0, 0, 0, 848, 851, 1, 0, 0, 0, 849, 847, 1, 0, 0, 0, 849, 850,
		1, 0, 0, 0, 850, 99, 1, 0, 0, 0, 851, 849, 1, 0, 0, 0, 852, 853, 3, 124,
		62, 0, 853, 855, 5, 215, 0, 0, 854, 856, 3, 104, 52, 0, 855, 854, 1, 0,
		0, 0, 855, 856, 1, 0, 0, 0, 856, 857, 1, 0, 0, 0, 857, 858, 5, 225, 0,
		0, 858, 101, 1, 0, 0, 0, 859, 860, 3, 108, 54, 0, 860, 861, 5, 207, 0,
		0, 861, 863, 1, 0, 0, 0, 862, 859, 1, 0, 0, 0, 862, 863, 1, 0, 0, 0, 863,
		864, 1, 0, 0, 0, 864, 865, 3, 124, 62, 0, 865, 103, 1, 0, 0, 0, 866, 871,
		3, 106, 53, 0, 867, 868, 5, 204, 0, 0, 868, 870, 3, 106, 53, 0, 869, 867,
		1, 0, 0, 0, 870, 873, 1, 0, 0, 0, 871, 869, 1, 0, 0, 0, 871, 872, 1, 0,
		0, 0, 872, 105, 1, 0, 0, 0, 873, 871, 1, 0, 0, 0, 874, 878, 3, 96, 48,
		0, 875, 878, 3, 100, 50, 0, 876, 878, 3, 114, 57, 0, 877, 874, 1, 0, 0,
		0, 877, 875, 1, 0, 0, 0, 877, 876, 1, 0, 0, 0, 878, 107, 1, 0, 0, 0, 879,
		880, 3, 124, 62, 0, 880, 109, 1, 0, 0, 0, 881, 890, 5, 194, 0, 0, 882,
		883, 5, 207, 0, 0, 883, 890, 7, 15, 0, 0, 884, 885, 5, 196, 0, 0, 885,
		887, 5, 207, 0, 0, 886, 888, 7, 15, 0, 0, 887, 886, 1, 0, 0, 0, 887, 888,
		1, 0, 0, 0, 888, 890, 1, 0, 0, 0, 889, 881, 1, 0, 0, 0, 889, 882, 1, 0,
		0, 0, 889, 884, 1, 0, 0, 0, 890, 111, 1, 0, 0, 0, 891, 893, 7, 16, 0, 0,
		892, 891, 1, 0, 0, 0, 892, 893, 1, 0, 0, 0, 893, 900, 1, 0, 0, 0, 894,
		901, 3, 110, 55, 0, 895, 901, 5, 195, 0, 0, 896, 901, 5, 196, 0, 0, 897,
		901, 5, 197, 0, 0, 898, 901, 5, 81, 0, 0, 899, 901, 5, 112, 0, 0, 900,
		894, 1, 0, 0, 0, 900, 895, 1, 0, 0, 0, 900, 896, 1, 0, 0, 0, 900, 897,
		1, 0, 0, 0, 900, 898, 1, 0, 0, 0, 900, 899, 1, 0, 0, 0, 901, 113, 1, 0,
		0, 0, 902, 906, 3, 112, 56, 0, 903, 906, 5, 198, 0, 0, 904, 906, 5, 115,
		0, 0, 905, 902, 1, 0, 0, 0, 905, 903, 1, 0, 0, 0, 905, 904, 1, 0, 0, 0,
		906, 115, 1, 0, 0, 0, 907, 908, 7, 17, 0, 0, 908, 117, 1, 0, 0, 0, 909,
		910, 7, 18, 0, 0, 910, 119, 1, 0, 0, 0, 911, 912, 7, 19, 0, 0, 912, 121,
		1, 0, 0, 0, 913, 916, 5, 193, 0, 0, 914, 916, 3, 120, 60, 0, 915, 913,
		1, 0, 0, 0, 915, 914, 1, 0, 0, 0, 916, 123, 1, 0, 0, 0, 917, 921, 5, 193,
		0, 0, 918, 921, 3, 116, 58, 0, 919, 921, 3, 118, 59, 0, 920, 917, 1, 0,
		0, 0, 920, 918, 1, 0, 0, 0, 920, 919, 1, 0, 0, 0, 921, 125, 1, 0, 0, 0,
		922, 925, 3, 124, 62, 0, 923, 925, 5, 115, 0, 0, 924, 922, 1, 0, 0, 0,
		924, 923, 1, 0, 0, 0, 925, 127, 1, 0, 0, 0, 926, 927, 5, 198, 0, 0, 927,
		928, 5, 209, 0, 0, 928, 929, 3, 112, 56, 0, 929, 129, 1, 0, 0, 0, 119,
		134, 138, 141, 144, 154, 159, 172, 183, 191, 194, 198, 201, 205, 208, 211,
		214, 217, 220, 223, 227, 231, 234, 237, 240, 243, 246, 249, 258, 264, 291,
		309, 320, 323, 329, 333, 336, 344, 348, 353, 356, 359, 363, 367, 370, 372,
		375, 379, 383, 386, 388, 390, 393, 398, 409, 415, 420, 430, 435, 439, 443,
		448, 455, 463, 466, 469, 488, 502, 515, 527, 539, 547, 551, 558, 564, 572,
		577, 586, 590, 621, 638, 650, 660, 663, 667, 670, 687, 704, 708, 725, 728,
		732, 735, 746, 770, 777, 779, 781, 789, 794, 802, 812, 815, 823, 830, 839,
		845, 849, 855, 862, 871, 877, 887, 889, 892, 900, 905, 915, 920, 924,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// DPParserInit initializes any static state used to implement DPParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewDPParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func DPParserInit() {
	staticData := &DPParserStaticData
	staticData.once.Do(dpParserInit)
}

// NewDPParser produces a new parser instance for the optional input antlr.TokenStream.
func NewDPParser(input antlr.TokenStream) *DPParser {
	DPParserInit()
	this := new(DPParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &DPParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "DP.g4"

	return this
}

// DPParser tokens.
const (
	DPParserEOF                 = antlr.TokenEOF
	DPParserADD                 = 1
	DPParserAFTER               = 2
	DPParserALIAS               = 3
	DPParserALL                 = 4
	DPParserALTER               = 5
	DPParserAND                 = 6
	DPParserANTI                = 7
	DPParserANY                 = 8
	DPParserARRAY               = 9
	DPParserAS                  = 10
	DPParserASCENDING           = 11
	DPParserASOF                = 12
	DPParserAST                 = 13
	DPParserASYNC               = 14
	DPParserATTACH              = 15
	DPParserBETWEEN             = 16
	DPParserBOTH                = 17
	DPParserBY                  = 18
	DPParserCASE                = 19
	DPParserCAST                = 20
	DPParserCHECK               = 21
	DPParserCLEAR               = 22
	DPParserCLUSTER             = 23
	DPParserCODEC               = 24
	DPParserCOLLATE             = 25
	DPParserCOLUMN              = 26
	DPParserCOMMENT             = 27
	DPParserCONSTRAINT          = 28
	DPParserCREATE              = 29
	DPParserCROSS               = 30
	DPParserCUBE                = 31
	DPParserCURRENT             = 32
	DPParserDATABASE            = 33
	DPParserDATABASES           = 34
	DPParserDATE                = 35
	DPParserDAY                 = 36
	DPParserDEDUPLICATE         = 37
	DPParserDEFAULT             = 38
	DPParserDELAY               = 39
	DPParserDELETE              = 40
	DPParserDESC                = 41
	DPParserDESCENDING          = 42
	DPParserDESCRIBE            = 43
	DPParserDETACH              = 44
	DPParserDICTIONARIES        = 45
	DPParserDICTIONARY          = 46
	DPParserDISK                = 47
	DPParserDISTINCT            = 48
	DPParserDISTRIBUTED         = 49
	DPParserDROP                = 50
	DPParserELSE                = 51
	DPParserEND                 = 52
	DPParserENGINE              = 53
	DPParserEVENTS              = 54
	DPParserEXISTS              = 55
	DPParserEXPLAIN             = 56
	DPParserEXPRESSION          = 57
	DPParserEXTRACT             = 58
	DPParserFETCHES             = 59
	DPParserFINAL               = 60
	DPParserFIRST               = 61
	DPParserFLUSH               = 62
	DPParserFOLLOWING           = 63
	DPParserFOR                 = 64
	DPParserFORMAT              = 65
	DPParserFREEZE              = 66
	DPParserFROM                = 67
	DPParserFULL                = 68
	DPParserFUNCTION            = 69
	DPParserGLOBAL              = 70
	DPParserGRANULARITY         = 71
	DPParserGROUP               = 72
	DPParserHAVING              = 73
	DPParserHIERARCHICAL        = 74
	DPParserHOUR                = 75
	DPParserID                  = 76
	DPParserIF                  = 77
	DPParserILIKE               = 78
	DPParserIN                  = 79
	DPParserINDEX               = 80
	DPParserINF                 = 81
	DPParserINJECTIVE           = 82
	DPParserINNER               = 83
	DPParserINSERT              = 84
	DPParserINTERVAL            = 85
	DPParserINTO                = 86
	DPParserIS                  = 87
	DPParserIS_OBJECT_ID        = 88
	DPParserJOIN                = 89
	DPParserKEY                 = 90
	DPParserKILL                = 91
	DPParserLAST                = 92
	DPParserLAYOUT              = 93
	DPParserLEADING             = 94
	DPParserLEFT                = 95
	DPParserLIFETIME            = 96
	DPParserLIKE                = 97
	DPParserLIMIT               = 98
	DPParserLIVE                = 99
	DPParserLOCAL               = 100
	DPParserLOGS                = 101
	DPParserMATERIALIZE         = 102
	DPParserMATERIALIZED        = 103
	DPParserMAX                 = 104
	DPParserMERGES              = 105
	DPParserMIN                 = 106
	DPParserMINUTE              = 107
	DPParserMODIFY              = 108
	DPParserMONTH               = 109
	DPParserMOVE                = 110
	DPParserMUTATION            = 111
	DPParserNAN_SQL             = 112
	DPParserNO                  = 113
	DPParserNOT                 = 114
	DPParserNULL_SQL            = 115
	DPParserNULLS               = 116
	DPParserOFFSET              = 117
	DPParserON                  = 118
	DPParserOPTIMIZE            = 119
	DPParserOR                  = 120
	DPParserORDER               = 121
	DPParserOUTER               = 122
	DPParserOUTFILE             = 123
	DPParserOVER                = 124
	DPParserPARTITION           = 125
	DPParserPOPULATE            = 126
	DPParserPRECEDING           = 127
	DPParserPREWHERE            = 128
	DPParserPRIMARY             = 129
	DPParserPROJECTION          = 130
	DPParserQUARTER             = 131
	DPParserRANGE               = 132
	DPParserRELOAD              = 133
	DPParserREMOVE              = 134
	DPParserRENAME              = 135
	DPParserREPLACE             = 136
	DPParserREPLICA             = 137
	DPParserREPLICATED          = 138
	DPParserRIGHT               = 139
	DPParserROLLUP              = 140
	DPParserROW                 = 141
	DPParserROWS                = 142
	DPParserSAMPLE              = 143
	DPParserSECOND              = 144
	DPParserSELECT              = 145
	DPParserSEMI                = 146
	DPParserSENDS               = 147
	DPParserSET                 = 148
	DPParserSETTINGS            = 149
	DPParserSHOW                = 150
	DPParserSOURCE              = 151
	DPParserSTART               = 152
	DPParserSTOP                = 153
	DPParserSUBSTRING           = 154
	DPParserSYNC                = 155
	DPParserSYNTAX              = 156
	DPParserSYSTEM              = 157
	DPParserTABLE               = 158
	DPParserTABLES              = 159
	DPParserTEALIMIT            = 160
	DPParserTEMPORARY           = 161
	DPParserTEST                = 162
	DPParserTHEN                = 163
	DPParserTIES                = 164
	DPParserTIMEOUT             = 165
	DPParserTIMESTAMP           = 166
	DPParserTO                  = 167
	DPParserTOP                 = 168
	DPParserTOTALS              = 169
	DPParserTRAILING            = 170
	DPParserTRIM                = 171
	DPParserTRUNCATE            = 172
	DPParserTTL                 = 173
	DPParserTYPE                = 174
	DPParserUNBOUNDED           = 175
	DPParserUNION               = 176
	DPParserUPDATE              = 177
	DPParserUSE                 = 178
	DPParserUSING               = 179
	DPParserUUID                = 180
	DPParserVALUES              = 181
	DPParserVIEW                = 182
	DPParserVOLUME              = 183
	DPParserWATCH               = 184
	DPParserWEEK                = 185
	DPParserWHEN                = 186
	DPParserWHERE               = 187
	DPParserWINDOW              = 188
	DPParserWITH                = 189
	DPParserYEAR                = 190
	DPParserJSON_FALSE          = 191
	DPParserJSON_TRUE           = 192
	DPParserIDENTIFIER          = 193
	DPParserFLOATING_LITERAL    = 194
	DPParserOCTAL_LITERAL       = 195
	DPParserDECIMAL_LITERAL     = 196
	DPParserHEXADECIMAL_LITERAL = 197
	DPParserSTRING_LITERAL      = 198
	DPParserARROW               = 199
	DPParserASTERISK            = 200
	DPParserBACKQUOTE           = 201
	DPParserBACKSLASH           = 202
	DPParserCOLON               = 203
	DPParserCOMMA               = 204
	DPParserCONCAT              = 205
	DPParserDASH                = 206
	DPParserDOT                 = 207
	DPParserEQ_DOUBLE           = 208
	DPParserEQ_SINGLE           = 209
	DPParserGE                  = 210
	DPParserGT                  = 211
	DPParserLBRACE              = 212
	DPParserLBRACKET            = 213
	DPParserLE                  = 214
	DPParserLPAREN              = 215
	DPParserLT                  = 216
	DPParserNOT_EQ              = 217
	DPParserPERCENT             = 218
	DPParserPLUS                = 219
	DPParserQUERY               = 220
	DPParserQUOTE_DOUBLE        = 221
	DPParserQUOTE_SINGLE        = 222
	DPParserRBRACE              = 223
	DPParserRBRACKET            = 224
	DPParserRPAREN              = 225
	DPParserSEMICOLON           = 226
	DPParserSLASH               = 227
	DPParserUNDERSCORE          = 228
	DPParserMULTI_LINE_COMMENT  = 229
	DPParserSINGLE_LINE_COMMENT = 230
	DPParserWHITESPACE          = 231
)

// DPParser rules.
const (
	DPParserRULE_queryStmt            = 0
	DPParserRULE_query                = 1
	DPParserRULE_ctes                 = 2
	DPParserRULE_namedQuery           = 3
	DPParserRULE_columnAliases        = 4
	DPParserRULE_selectUnionStmt      = 5
	DPParserRULE_selectStmtWithParens = 6
	DPParserRULE_selectStmt           = 7
	DPParserRULE_withClause           = 8
	DPParserRULE_topClause            = 9
	DPParserRULE_fromClause           = 10
	DPParserRULE_arrayJoinClause      = 11
	DPParserRULE_windowClause         = 12
	DPParserRULE_prewhereClause       = 13
	DPParserRULE_whereClause          = 14
	DPParserRULE_groupByClause        = 15
	DPParserRULE_havingClause         = 16
	DPParserRULE_orderByClause        = 17
	DPParserRULE_limitByClause        = 18
	DPParserRULE_limitClause          = 19
	DPParserRULE_tealimitClause       = 20
	DPParserRULE_settingsClause       = 21
	DPParserRULE_joinExpr             = 22
	DPParserRULE_joinOp               = 23
	DPParserRULE_joinOpCross          = 24
	DPParserRULE_joinConstraintClause = 25
	DPParserRULE_sampleClause         = 26
	DPParserRULE_limitExpr            = 27
	DPParserRULE_tealimitExpr         = 28
	DPParserRULE_orderExprList        = 29
	DPParserRULE_orderExpr            = 30
	DPParserRULE_ratioExpr            = 31
	DPParserRULE_settingExprList      = 32
	DPParserRULE_settingExpr          = 33
	DPParserRULE_windowExpr           = 34
	DPParserRULE_winPartitionByClause = 35
	DPParserRULE_winOrderByClause     = 36
	DPParserRULE_winFrameClause       = 37
	DPParserRULE_winFrameExtend       = 38
	DPParserRULE_winFrameBound        = 39
	DPParserRULE_columnTypeExpr       = 40
	DPParserRULE_columnExprList       = 41
	DPParserRULE_columnsExpr          = 42
	DPParserRULE_columnExpr           = 43
	DPParserRULE_columnArgList        = 44
	DPParserRULE_columnArgExpr        = 45
	DPParserRULE_columnLambdaExpr     = 46
	DPParserRULE_columnIdentifier     = 47
	DPParserRULE_nestedIdentifier     = 48
	DPParserRULE_tableExpr            = 49
	DPParserRULE_tableFunctionExpr    = 50
	DPParserRULE_tableIdentifier      = 51
	DPParserRULE_tableArgList         = 52
	DPParserRULE_tableArgExpr         = 53
	DPParserRULE_databaseIdentifier   = 54
	DPParserRULE_floatingLiteral      = 55
	DPParserRULE_numberLiteral        = 56
	DPParserRULE_literal              = 57
	DPParserRULE_interval             = 58
	DPParserRULE_keyword              = 59
	DPParserRULE_keywordForAlias      = 60
	DPParserRULE_alias                = 61
	DPParserRULE_identifier           = 62
	DPParserRULE_identifierOrNull     = 63
	DPParserRULE_enumValue            = 64
)

// IQueryStmtContext is an interface to support dynamic dispatch.
type IQueryStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query() IQueryContext
	INTO() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	IdentifierOrNull() IIdentifierOrNullContext
	SEMICOLON() antlr.TerminalNode

	// IsQueryStmtContext differentiates from other interfaces.
	IsQueryStmtContext()
}

type QueryStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryStmtContext() *QueryStmtContext {
	var p = new(QueryStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_queryStmt
	return p
}

func InitEmptyQueryStmtContext(p *QueryStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_queryStmt
}

func (*QueryStmtContext) IsQueryStmtContext() {}

func NewQueryStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStmtContext {
	var p = new(QueryStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_queryStmt

	return p
}

func (s *QueryStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStmtContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QueryStmtContext) INTO() antlr.TerminalNode {
	return s.GetToken(DPParserINTO, 0)
}

func (s *QueryStmtContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(DPParserOUTFILE, 0)
}

func (s *QueryStmtContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserSTRING_LITERAL, 0)
}

func (s *QueryStmtContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DPParserFORMAT, 0)
}

func (s *QueryStmtContext) IdentifierOrNull() IIdentifierOrNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrNullContext)
}

func (s *QueryStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(DPParserSEMICOLON, 0)
}

func (s *QueryStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterQueryStmt(s)
	}
}

func (s *QueryStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitQueryStmt(s)
	}
}

func (s *QueryStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitQueryStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) QueryStmt() (localctx IQueryStmtContext) {
	localctx = NewQueryStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, DPParserRULE_queryStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(130)
		p.Query()
	}
	p.SetState(134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserINTO {
		{
			p.SetState(131)
			p.Match(DPParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(132)
			p.Match(DPParserOUTFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(133)
			p.Match(DPParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserFORMAT {
		{
			p.SetState(136)
			p.Match(DPParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(137)
			p.IdentifierOrNull()
		}

	}
	p.SetState(141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserSEMICOLON {
		{
			p.SetState(140)
			p.Match(DPParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectStmt() ISelectStmtContext
	Ctes() ICtesContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) SelectStmt() ISelectStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStmtContext)
}

func (s *QueryContext) Ctes() ICtesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICtesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICtesContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, DPParserRULE_query)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(144)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(143)
			p.Ctes()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(146)
		p.SelectStmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICtesContext is an interface to support dynamic dispatch.
type ICtesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllNamedQuery() []INamedQueryContext
	NamedQuery(i int) INamedQueryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCtesContext differentiates from other interfaces.
	IsCtesContext()
}

type CtesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCtesContext() *CtesContext {
	var p = new(CtesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_ctes
	return p
}

func InitEmptyCtesContext(p *CtesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_ctes
}

func (*CtesContext) IsCtesContext() {}

func NewCtesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CtesContext {
	var p = new(CtesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_ctes

	return p
}

func (s *CtesContext) GetParser() antlr.Parser { return s.parser }

func (s *CtesContext) WITH() antlr.TerminalNode {
	return s.GetToken(DPParserWITH, 0)
}

func (s *CtesContext) AllNamedQuery() []INamedQueryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedQueryContext); ok {
			len++
		}
	}

	tst := make([]INamedQueryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedQueryContext); ok {
			tst[i] = t.(INamedQueryContext)
			i++
		}
	}

	return tst
}

func (s *CtesContext) NamedQuery(i int) INamedQueryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedQueryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedQueryContext)
}

func (s *CtesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DPParserCOMMA)
}

func (s *CtesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, i)
}

func (s *CtesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CtesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CtesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterCtes(s)
	}
}

func (s *CtesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitCtes(s)
	}
}

func (s *CtesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitCtes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) Ctes() (localctx ICtesContext) {
	localctx = NewCtesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, DPParserRULE_ctes)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(148)
		p.Match(DPParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(149)
		p.NamedQuery()
	}
	p.SetState(154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DPParserCOMMA {
		{
			p.SetState(150)
			p.Match(DPParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(151)
			p.NamedQuery()
		}

		p.SetState(156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedQueryContext is an interface to support dynamic dispatch.
type INamedQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	AS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Query() IQueryContext
	RPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	ColumnAliases() IColumnAliasesContext

	// IsNamedQueryContext differentiates from other interfaces.
	IsNamedQueryContext()
}

type NamedQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyNamedQueryContext() *NamedQueryContext {
	var p = new(NamedQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_namedQuery
	return p
}

func InitEmptyNamedQueryContext(p *NamedQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_namedQuery
}

func (*NamedQueryContext) IsNamedQueryContext() {}

func NewNamedQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedQueryContext {
	var p = new(NamedQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_namedQuery

	return p
}

func (s *NamedQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedQueryContext) GetName() IIdentifierContext { return s.name }

func (s *NamedQueryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *NamedQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(DPParserAS, 0)
}

func (s *NamedQueryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *NamedQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *NamedQueryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *NamedQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedQueryContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NamedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterNamedQuery(s)
	}
}

func (s *NamedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitNamedQuery(s)
	}
}

func (s *NamedQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitNamedQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) NamedQuery() (localctx INamedQueryContext) {
	localctx = NewNamedQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, DPParserRULE_namedQuery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(157)

		var _x = p.Identifier()

		localctx.(*NamedQueryContext).name = _x
	}
	p.SetState(159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserLPAREN {
		{
			p.SetState(158)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(161)
		p.Match(DPParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(162)
		p.Match(DPParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(163)
		p.Query()
	}
	{
		p.SetState(164)
		p.Match(DPParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnAliases
	return p
}

func InitEmptyColumnAliasesContext(p *ColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnAliases
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnAliasesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DPParserCOMMA)
}

func (s *ColumnAliasesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, i)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnAliases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, DPParserRULE_columnAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(166)
		p.Match(DPParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(167)
		p.Identifier()
	}
	p.SetState(172)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DPParserCOMMA {
		{
			p.SetState(168)
			p.Match(DPParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(169)
			p.Identifier()
		}

		p.SetState(174)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(175)
		p.Match(DPParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectUnionStmtContext is an interface to support dynamic dispatch.
type ISelectUnionStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelectStmtWithParens() []ISelectStmtWithParensContext
	SelectStmtWithParens(i int) ISelectStmtWithParensContext
	AllUNION() []antlr.TerminalNode
	UNION(i int) antlr.TerminalNode
	AllALL() []antlr.TerminalNode
	ALL(i int) antlr.TerminalNode

	// IsSelectUnionStmtContext differentiates from other interfaces.
	IsSelectUnionStmtContext()
}

type SelectUnionStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectUnionStmtContext() *SelectUnionStmtContext {
	var p = new(SelectUnionStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_selectUnionStmt
	return p
}

func InitEmptySelectUnionStmtContext(p *SelectUnionStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_selectUnionStmt
}

func (*SelectUnionStmtContext) IsSelectUnionStmtContext() {}

func NewSelectUnionStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectUnionStmtContext {
	var p = new(SelectUnionStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_selectUnionStmt

	return p
}

func (s *SelectUnionStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectUnionStmtContext) AllSelectStmtWithParens() []ISelectStmtWithParensContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectStmtWithParensContext); ok {
			len++
		}
	}

	tst := make([]ISelectStmtWithParensContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectStmtWithParensContext); ok {
			tst[i] = t.(ISelectStmtWithParensContext)
			i++
		}
	}

	return tst
}

func (s *SelectUnionStmtContext) SelectStmtWithParens(i int) ISelectStmtWithParensContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStmtWithParensContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStmtWithParensContext)
}

func (s *SelectUnionStmtContext) AllUNION() []antlr.TerminalNode {
	return s.GetTokens(DPParserUNION)
}

func (s *SelectUnionStmtContext) UNION(i int) antlr.TerminalNode {
	return s.GetToken(DPParserUNION, i)
}

func (s *SelectUnionStmtContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(DPParserALL)
}

func (s *SelectUnionStmtContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(DPParserALL, i)
}

func (s *SelectUnionStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectUnionStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectUnionStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterSelectUnionStmt(s)
	}
}

func (s *SelectUnionStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitSelectUnionStmt(s)
	}
}

func (s *SelectUnionStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitSelectUnionStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) SelectUnionStmt() (localctx ISelectUnionStmtContext) {
	localctx = NewSelectUnionStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, DPParserRULE_selectUnionStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(177)
		p.SelectStmtWithParens()
	}
	p.SetState(183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DPParserUNION {
		{
			p.SetState(178)
			p.Match(DPParserUNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(179)
			p.Match(DPParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(180)
			p.SelectStmtWithParens()
		}

		p.SetState(185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStmtWithParensContext is an interface to support dynamic dispatch.
type ISelectStmtWithParensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectStmt() ISelectStmtContext
	LPAREN() antlr.TerminalNode
	SelectUnionStmt() ISelectUnionStmtContext
	RPAREN() antlr.TerminalNode

	// IsSelectStmtWithParensContext differentiates from other interfaces.
	IsSelectStmtWithParensContext()
}

type SelectStmtWithParensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStmtWithParensContext() *SelectStmtWithParensContext {
	var p = new(SelectStmtWithParensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_selectStmtWithParens
	return p
}

func InitEmptySelectStmtWithParensContext(p *SelectStmtWithParensContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_selectStmtWithParens
}

func (*SelectStmtWithParensContext) IsSelectStmtWithParensContext() {}

func NewSelectStmtWithParensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStmtWithParensContext {
	var p = new(SelectStmtWithParensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_selectStmtWithParens

	return p
}

func (s *SelectStmtWithParensContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStmtWithParensContext) SelectStmt() ISelectStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStmtContext)
}

func (s *SelectStmtWithParensContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *SelectStmtWithParensContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *SelectStmtWithParensContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *SelectStmtWithParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStmtWithParensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStmtWithParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterSelectStmtWithParens(s)
	}
}

func (s *SelectStmtWithParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitSelectStmtWithParens(s)
	}
}

func (s *SelectStmtWithParensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitSelectStmtWithParens(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) SelectStmtWithParens() (localctx ISelectStmtWithParensContext) {
	localctx = NewSelectStmtWithParensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, DPParserRULE_selectStmtWithParens)
	p.SetState(191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DPParserSELECT, DPParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(186)
			p.SelectStmt()
		}

	case DPParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(187)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(188)
			p.SelectUnionStmt()
		}
		{
			p.SetState(189)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStmtContext is an interface to support dynamic dispatch.
type ISelectStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext
	WithClause() IWithClauseContext
	DISTINCT() antlr.TerminalNode
	TopClause() ITopClauseContext
	COMMA() antlr.TerminalNode
	FromClause() IFromClauseContext
	ArrayJoinClause() IArrayJoinClauseContext
	WindowClause() IWindowClauseContext
	PrewhereClause() IPrewhereClauseContext
	WhereClause() IWhereClauseContext
	GroupByClause() IGroupByClauseContext
	AllWITH() []antlr.TerminalNode
	WITH(i int) antlr.TerminalNode
	TOTALS() antlr.TerminalNode
	HavingClause() IHavingClauseContext
	OrderByClause() IOrderByClauseContext
	LimitByClause() ILimitByClauseContext
	LimitClause() ILimitClauseContext
	TealimitClause() ITealimitClauseContext
	SettingsClause() ISettingsClauseContext
	CUBE() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode

	// IsSelectStmtContext differentiates from other interfaces.
	IsSelectStmtContext()
}

type SelectStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStmtContext() *SelectStmtContext {
	var p = new(SelectStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_selectStmt
	return p
}

func InitEmptySelectStmtContext(p *SelectStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_selectStmt
}

func (*SelectStmtContext) IsSelectStmtContext() {}

func NewSelectStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStmtContext {
	var p = new(SelectStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_selectStmt

	return p
}

func (s *SelectStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStmtContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DPParserSELECT, 0)
}

func (s *SelectStmtContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *SelectStmtContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *SelectStmtContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DPParserDISTINCT, 0)
}

func (s *SelectStmtContext) TopClause() ITopClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopClauseContext)
}

func (s *SelectStmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, 0)
}

func (s *SelectStmtContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *SelectStmtContext) ArrayJoinClause() IArrayJoinClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayJoinClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayJoinClauseContext)
}

func (s *SelectStmtContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *SelectStmtContext) PrewhereClause() IPrewhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrewhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrewhereClauseContext)
}

func (s *SelectStmtContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *SelectStmtContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *SelectStmtContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(DPParserWITH)
}

func (s *SelectStmtContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(DPParserWITH, i)
}

func (s *SelectStmtContext) TOTALS() antlr.TerminalNode {
	return s.GetToken(DPParserTOTALS, 0)
}

func (s *SelectStmtContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *SelectStmtContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SelectStmtContext) LimitByClause() ILimitByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitByClauseContext)
}

func (s *SelectStmtContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SelectStmtContext) TealimitClause() ITealimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITealimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITealimitClauseContext)
}

func (s *SelectStmtContext) SettingsClause() ISettingsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISettingsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISettingsClauseContext)
}

func (s *SelectStmtContext) CUBE() antlr.TerminalNode {
	return s.GetToken(DPParserCUBE, 0)
}

func (s *SelectStmtContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DPParserROLLUP, 0)
}

func (s *SelectStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterSelectStmt(s)
	}
}

func (s *SelectStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitSelectStmt(s)
	}
}

func (s *SelectStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitSelectStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) SelectStmt() (localctx ISelectStmtContext) {
	localctx = NewSelectStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, DPParserRULE_selectStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(194)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserWITH {
		{
			p.SetState(193)
			p.WithClause()
		}

	}
	{
		p.SetState(196)
		p.Match(DPParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(198)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(197)
			p.Match(DPParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(201)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(200)
			p.TopClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(203)
		p.ColumnExprList()
	}
	p.SetState(205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserCOMMA {
		{
			p.SetState(204)
			p.Match(DPParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserFROM {
		{
			p.SetState(207)
			p.FromClause()
		}

	}
	p.SetState(211)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserARRAY || _la == DPParserINNER || _la == DPParserLEFT {
		{
			p.SetState(210)
			p.ArrayJoinClause()
		}

	}
	p.SetState(214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserWINDOW {
		{
			p.SetState(213)
			p.WindowClause()
		}

	}
	p.SetState(217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserPREWHERE {
		{
			p.SetState(216)
			p.PrewhereClause()
		}

	}
	p.SetState(220)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserWHERE {
		{
			p.SetState(219)
			p.WhereClause()
		}

	}
	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserGROUP {
		{
			p.SetState(222)
			p.GroupByClause()
		}

	}
	p.SetState(227)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(225)
			p.Match(DPParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(226)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DPParserCUBE || _la == DPParserROLLUP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserWITH {
		{
			p.SetState(229)
			p.Match(DPParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(230)
			p.Match(DPParserTOTALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserHAVING {
		{
			p.SetState(233)
			p.HavingClause()
		}

	}
	p.SetState(237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserORDER {
		{
			p.SetState(236)
			p.OrderByClause()
		}

	}
	p.SetState(240)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(239)
			p.LimitByClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(243)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserLIMIT {
		{
			p.SetState(242)
			p.LimitClause()
		}

	}
	p.SetState(246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserTEALIMIT {
		{
			p.SetState(245)
			p.TealimitClause()
		}

	}
	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserSETTINGS {
		{
			p.SetState(248)
			p.SettingsClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DPParserWITH, 0)
}

func (s *WithClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, DPParserRULE_withClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(251)
		p.Match(DPParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(252)
		p.ColumnExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopClauseContext is an interface to support dynamic dispatch.
type ITopClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TOP() antlr.TerminalNode
	DECIMAL_LITERAL() antlr.TerminalNode
	WITH() antlr.TerminalNode
	TIES() antlr.TerminalNode

	// IsTopClauseContext differentiates from other interfaces.
	IsTopClauseContext()
}

type TopClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopClauseContext() *TopClauseContext {
	var p = new(TopClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_topClause
	return p
}

func InitEmptyTopClauseContext(p *TopClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_topClause
}

func (*TopClauseContext) IsTopClauseContext() {}

func NewTopClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopClauseContext {
	var p = new(TopClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_topClause

	return p
}

func (s *TopClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TopClauseContext) TOP() antlr.TerminalNode {
	return s.GetToken(DPParserTOP, 0)
}

func (s *TopClauseContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserDECIMAL_LITERAL, 0)
}

func (s *TopClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DPParserWITH, 0)
}

func (s *TopClauseContext) TIES() antlr.TerminalNode {
	return s.GetToken(DPParserTIES, 0)
}

func (s *TopClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterTopClause(s)
	}
}

func (s *TopClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitTopClause(s)
	}
}

func (s *TopClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitTopClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) TopClause() (localctx ITopClauseContext) {
	localctx = NewTopClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, DPParserRULE_topClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(254)
		p.Match(DPParserTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(255)
		p.Match(DPParserDECIMAL_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(258)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(256)
			p.Match(DPParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(257)
			p.Match(DPParserTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	JoinExpr() IJoinExprContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DPParserFROM, 0)
}

func (s *FromClauseContext) JoinExpr() IJoinExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinExprContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, DPParserRULE_fromClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(260)
		p.Match(DPParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(261)
		p.joinExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayJoinClauseContext is an interface to support dynamic dispatch.
type IArrayJoinClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext
	LEFT() antlr.TerminalNode
	INNER() antlr.TerminalNode

	// IsArrayJoinClauseContext differentiates from other interfaces.
	IsArrayJoinClauseContext()
}

type ArrayJoinClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayJoinClauseContext() *ArrayJoinClauseContext {
	var p = new(ArrayJoinClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_arrayJoinClause
	return p
}

func InitEmptyArrayJoinClauseContext(p *ArrayJoinClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_arrayJoinClause
}

func (*ArrayJoinClauseContext) IsArrayJoinClauseContext() {}

func NewArrayJoinClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayJoinClauseContext {
	var p = new(ArrayJoinClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_arrayJoinClause

	return p
}

func (s *ArrayJoinClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayJoinClauseContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DPParserARRAY, 0)
}

func (s *ArrayJoinClauseContext) JOIN() antlr.TerminalNode {
	return s.GetToken(DPParserJOIN, 0)
}

func (s *ArrayJoinClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ArrayJoinClauseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DPParserLEFT, 0)
}

func (s *ArrayJoinClauseContext) INNER() antlr.TerminalNode {
	return s.GetToken(DPParserINNER, 0)
}

func (s *ArrayJoinClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayJoinClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayJoinClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterArrayJoinClause(s)
	}
}

func (s *ArrayJoinClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitArrayJoinClause(s)
	}
}

func (s *ArrayJoinClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitArrayJoinClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) ArrayJoinClause() (localctx IArrayJoinClauseContext) {
	localctx = NewArrayJoinClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, DPParserRULE_arrayJoinClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserINNER || _la == DPParserLEFT {
		{
			p.SetState(263)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DPParserINNER || _la == DPParserLEFT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(266)
		p.Match(DPParserARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(267)
		p.Match(DPParserJOIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(268)
		p.ColumnExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowClauseContext is an interface to support dynamic dispatch.
type IWindowClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW() antlr.TerminalNode
	Identifier() IIdentifierContext
	AS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	WindowExpr() IWindowExprContext
	RPAREN() antlr.TerminalNode

	// IsWindowClauseContext differentiates from other interfaces.
	IsWindowClauseContext()
}

type WindowClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowClauseContext() *WindowClauseContext {
	var p = new(WindowClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_windowClause
	return p
}

func InitEmptyWindowClauseContext(p *WindowClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_windowClause
}

func (*WindowClauseContext) IsWindowClauseContext() {}

func NewWindowClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowClauseContext {
	var p = new(WindowClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_windowClause

	return p
}

func (s *WindowClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowClauseContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(DPParserWINDOW, 0)
}

func (s *WindowClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WindowClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(DPParserAS, 0)
}

func (s *WindowClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *WindowClauseContext) WindowExpr() IWindowExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowExprContext)
}

func (s *WindowClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *WindowClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterWindowClause(s)
	}
}

func (s *WindowClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitWindowClause(s)
	}
}

func (s *WindowClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitWindowClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) WindowClause() (localctx IWindowClauseContext) {
	localctx = NewWindowClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, DPParserRULE_windowClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(270)
		p.Match(DPParserWINDOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(271)
		p.Identifier()
	}
	{
		p.SetState(272)
		p.Match(DPParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(273)
		p.Match(DPParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(274)
		p.WindowExpr()
	}
	{
		p.SetState(275)
		p.Match(DPParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrewhereClauseContext is an interface to support dynamic dispatch.
type IPrewhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREWHERE() antlr.TerminalNode
	ColumnExpr() IColumnExprContext

	// IsPrewhereClauseContext differentiates from other interfaces.
	IsPrewhereClauseContext()
}

type PrewhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrewhereClauseContext() *PrewhereClauseContext {
	var p = new(PrewhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_prewhereClause
	return p
}

func InitEmptyPrewhereClauseContext(p *PrewhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_prewhereClause
}

func (*PrewhereClauseContext) IsPrewhereClauseContext() {}

func NewPrewhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrewhereClauseContext {
	var p = new(PrewhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_prewhereClause

	return p
}

func (s *PrewhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrewhereClauseContext) PREWHERE() antlr.TerminalNode {
	return s.GetToken(DPParserPREWHERE, 0)
}

func (s *PrewhereClauseContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *PrewhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrewhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrewhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterPrewhereClause(s)
	}
}

func (s *PrewhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitPrewhereClause(s)
	}
}

func (s *PrewhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitPrewhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) PrewhereClause() (localctx IPrewhereClauseContext) {
	localctx = NewPrewhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, DPParserRULE_prewhereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(277)
		p.Match(DPParserPREWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(278)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	ColumnExpr() IColumnExprContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DPParserWHERE, 0)
}

func (s *WhereClauseContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, DPParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(280)
		p.Match(DPParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(281)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext
	RPAREN() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DPParserGROUP, 0)
}

func (s *GroupByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DPParserBY, 0)
}

func (s *GroupByClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *GroupByClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *GroupByClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *GroupByClauseContext) CUBE() antlr.TerminalNode {
	return s.GetToken(DPParserCUBE, 0)
}

func (s *GroupByClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DPParserROLLUP, 0)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (s *GroupByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitGroupByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, DPParserRULE_groupByClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.Match(DPParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(284)
		p.Match(DPParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(285)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DPParserCUBE || _la == DPParserROLLUP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(286)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(287)
			p.ColumnExprList()
		}
		{
			p.SetState(288)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(290)
			p.ColumnExprList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING() antlr.TerminalNode
	ColumnExpr() IColumnExprContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(DPParserHAVING, 0)
}

func (s *HavingClauseContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (s *HavingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitHavingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, DPParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(293)
		p.Match(DPParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(294)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	OrderExprList() IOrderExprListContext

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_orderByClause
	return p
}

func InitEmptyOrderByClauseContext(p *OrderByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_orderByClause
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DPParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DPParserBY, 0)
}

func (s *OrderByClauseContext) OrderExprList() IOrderExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderExprListContext)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (s *OrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitOrderByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, DPParserRULE_orderByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(296)
		p.Match(DPParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(297)
		p.Match(DPParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(298)
		p.OrderExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitByClauseContext is an interface to support dynamic dispatch.
type ILimitByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	LimitExpr() ILimitExprContext
	BY() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext

	// IsLimitByClauseContext differentiates from other interfaces.
	IsLimitByClauseContext()
}

type LimitByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitByClauseContext() *LimitByClauseContext {
	var p = new(LimitByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_limitByClause
	return p
}

func InitEmptyLimitByClauseContext(p *LimitByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_limitByClause
}

func (*LimitByClauseContext) IsLimitByClauseContext() {}

func NewLimitByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitByClauseContext {
	var p = new(LimitByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_limitByClause

	return p
}

func (s *LimitByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitByClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DPParserLIMIT, 0)
}

func (s *LimitByClauseContext) LimitExpr() ILimitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitExprContext)
}

func (s *LimitByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DPParserBY, 0)
}

func (s *LimitByClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *LimitByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterLimitByClause(s)
	}
}

func (s *LimitByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitLimitByClause(s)
	}
}

func (s *LimitByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitLimitByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) LimitByClause() (localctx ILimitByClauseContext) {
	localctx = NewLimitByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, DPParserRULE_limitByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(300)
		p.Match(DPParserLIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(301)
		p.LimitExpr()
	}
	{
		p.SetState(302)
		p.Match(DPParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(303)
		p.ColumnExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	LimitExpr() ILimitExprContext
	WITH() antlr.TerminalNode
	TIES() antlr.TerminalNode

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DPParserLIMIT, 0)
}

func (s *LimitClauseContext) LimitExpr() ILimitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitExprContext)
}

func (s *LimitClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DPParserWITH, 0)
}

func (s *LimitClauseContext) TIES() antlr.TerminalNode {
	return s.GetToken(DPParserTIES, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, DPParserRULE_limitClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(305)
		p.Match(DPParserLIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(306)
		p.LimitExpr()
	}
	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserWITH {
		{
			p.SetState(307)
			p.Match(DPParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(308)
			p.Match(DPParserTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITealimitClauseContext is an interface to support dynamic dispatch.
type ITealimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TEALIMIT() antlr.TerminalNode
	TealimitExpr() ITealimitExprContext

	// IsTealimitClauseContext differentiates from other interfaces.
	IsTealimitClauseContext()
}

type TealimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTealimitClauseContext() *TealimitClauseContext {
	var p = new(TealimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tealimitClause
	return p
}

func InitEmptyTealimitClauseContext(p *TealimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tealimitClause
}

func (*TealimitClauseContext) IsTealimitClauseContext() {}

func NewTealimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TealimitClauseContext {
	var p = new(TealimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_tealimitClause

	return p
}

func (s *TealimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TealimitClauseContext) TEALIMIT() antlr.TerminalNode {
	return s.GetToken(DPParserTEALIMIT, 0)
}

func (s *TealimitClauseContext) TealimitExpr() ITealimitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITealimitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITealimitExprContext)
}

func (s *TealimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TealimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TealimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterTealimitClause(s)
	}
}

func (s *TealimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitTealimitClause(s)
	}
}

func (s *TealimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitTealimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) TealimitClause() (localctx ITealimitClauseContext) {
	localctx = NewTealimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, DPParserRULE_tealimitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(311)
		p.Match(DPParserTEALIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(312)
		p.TealimitExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISettingsClauseContext is an interface to support dynamic dispatch.
type ISettingsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SETTINGS() antlr.TerminalNode
	SettingExprList() ISettingExprListContext

	// IsSettingsClauseContext differentiates from other interfaces.
	IsSettingsClauseContext()
}

type SettingsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySettingsClauseContext() *SettingsClauseContext {
	var p = new(SettingsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_settingsClause
	return p
}

func InitEmptySettingsClauseContext(p *SettingsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_settingsClause
}

func (*SettingsClauseContext) IsSettingsClauseContext() {}

func NewSettingsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SettingsClauseContext {
	var p = new(SettingsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_settingsClause

	return p
}

func (s *SettingsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SettingsClauseContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(DPParserSETTINGS, 0)
}

func (s *SettingsClauseContext) SettingExprList() ISettingExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISettingExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISettingExprListContext)
}

func (s *SettingsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SettingsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SettingsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterSettingsClause(s)
	}
}

func (s *SettingsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitSettingsClause(s)
	}
}

func (s *SettingsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitSettingsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) SettingsClause() (localctx ISettingsClauseContext) {
	localctx = NewSettingsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, DPParserRULE_settingsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(314)
		p.Match(DPParserSETTINGS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(315)
		p.SettingExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinExprContext is an interface to support dynamic dispatch.
type IJoinExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsJoinExprContext differentiates from other interfaces.
	IsJoinExprContext()
}

type JoinExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinExprContext() *JoinExprContext {
	var p = new(JoinExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_joinExpr
	return p
}

func InitEmptyJoinExprContext(p *JoinExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_joinExpr
}

func (*JoinExprContext) IsJoinExprContext() {}

func NewJoinExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinExprContext {
	var p = new(JoinExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_joinExpr

	return p
}

func (s *JoinExprContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinExprContext) CopyAll(ctx *JoinExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *JoinExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type JoinExprOpContext struct {
	JoinExprContext
}

func NewJoinExprOpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinExprOpContext {
	var p = new(JoinExprOpContext)

	InitEmptyJoinExprContext(&p.JoinExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinExprContext))

	return p
}

func (s *JoinExprOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprOpContext) AllJoinExpr() []IJoinExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinExprContext); ok {
			len++
		}
	}

	tst := make([]IJoinExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinExprContext); ok {
			tst[i] = t.(IJoinExprContext)
			i++
		}
	}

	return tst
}

func (s *JoinExprOpContext) JoinExpr(i int) IJoinExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinExprContext)
}

func (s *JoinExprOpContext) JOIN() antlr.TerminalNode {
	return s.GetToken(DPParserJOIN, 0)
}

func (s *JoinExprOpContext) JoinConstraintClause() IJoinConstraintClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinConstraintClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinConstraintClauseContext)
}

func (s *JoinExprOpContext) JoinOp() IJoinOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinOpContext)
}

func (s *JoinExprOpContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DPParserGLOBAL, 0)
}

func (s *JoinExprOpContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DPParserLOCAL, 0)
}

func (s *JoinExprOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterJoinExprOp(s)
	}
}

func (s *JoinExprOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitJoinExprOp(s)
	}
}

func (s *JoinExprOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitJoinExprOp(s)

	default:
		return t.VisitChildren(s)
	}
}

type JoinExprTableContext struct {
	JoinExprContext
}

func NewJoinExprTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinExprTableContext {
	var p = new(JoinExprTableContext)

	InitEmptyJoinExprContext(&p.JoinExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinExprContext))

	return p
}

func (s *JoinExprTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprTableContext) TableExpr() ITableExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableExprContext)
}

func (s *JoinExprTableContext) FINAL() antlr.TerminalNode {
	return s.GetToken(DPParserFINAL, 0)
}

func (s *JoinExprTableContext) SampleClause() ISampleClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleClauseContext)
}

func (s *JoinExprTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterJoinExprTable(s)
	}
}

func (s *JoinExprTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitJoinExprTable(s)
	}
}

func (s *JoinExprTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitJoinExprTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type JoinExprParensContext struct {
	JoinExprContext
}

func NewJoinExprParensContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinExprParensContext {
	var p = new(JoinExprParensContext)

	InitEmptyJoinExprContext(&p.JoinExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinExprContext))

	return p
}

func (s *JoinExprParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprParensContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *JoinExprParensContext) JoinExpr() IJoinExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinExprContext)
}

func (s *JoinExprParensContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *JoinExprParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterJoinExprParens(s)
	}
}

func (s *JoinExprParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitJoinExprParens(s)
	}
}

func (s *JoinExprParensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitJoinExprParens(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) JoinExpr() (localctx IJoinExprContext) {
	return p.joinExpr(0)
}

func (p *DPParser) joinExpr(_p int) (localctx IJoinExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewJoinExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IJoinExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 44
	p.EnterRecursionRule(localctx, 44, DPParserRULE_joinExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		localctx = NewJoinExprTableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(318)
			p.tableExpr(0)
		}
		p.SetState(320)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(319)
				p.Match(DPParserFINAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(323)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(322)
				p.SampleClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewJoinExprParensContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(325)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(326)
			p.joinExpr(0)
		}
		{
			p.SetState(327)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewJoinExprOpContext(p, NewJoinExprContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, DPParserRULE_joinExpr)
			p.SetState(331)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				goto errorExit
			}
			p.SetState(333)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DPParserGLOBAL || _la == DPParserLOCAL {
				{
					p.SetState(332)
					_la = p.GetTokenStream().LA(1)

					if !(_la == DPParserGLOBAL || _la == DPParserLOCAL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(336)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4496) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&134250497) != 0) || _la == DPParserRIGHT || _la == DPParserSEMI {
				{
					p.SetState(335)
					p.JoinOp()
				}

			}
			{
				p.SetState(338)
				p.Match(DPParserJOIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(339)
				p.joinExpr(0)
			}
			{
				p.SetState(340)
				p.JoinConstraintClause()
			}

		}
		p.SetState(346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinOpContext is an interface to support dynamic dispatch.
type IJoinOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsJoinOpContext differentiates from other interfaces.
	IsJoinOpContext()
}

type JoinOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinOpContext() *JoinOpContext {
	var p = new(JoinOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_joinOp
	return p
}

func InitEmptyJoinOpContext(p *JoinOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_joinOp
}

func (*JoinOpContext) IsJoinOpContext() {}

func NewJoinOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinOpContext {
	var p = new(JoinOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_joinOp

	return p
}

func (s *JoinOpContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinOpContext) CopyAll(ctx *JoinOpContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *JoinOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type JoinOpFullContext struct {
	JoinOpContext
}

func NewJoinOpFullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinOpFullContext {
	var p = new(JoinOpFullContext)

	InitEmptyJoinOpContext(&p.JoinOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinOpContext))

	return p
}

func (s *JoinOpFullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpFullContext) FULL() antlr.TerminalNode {
	return s.GetToken(DPParserFULL, 0)
}

func (s *JoinOpFullContext) OUTER() antlr.TerminalNode {
	return s.GetToken(DPParserOUTER, 0)
}

func (s *JoinOpFullContext) ALL() antlr.TerminalNode {
	return s.GetToken(DPParserALL, 0)
}

func (s *JoinOpFullContext) ANY() antlr.TerminalNode {
	return s.GetToken(DPParserANY, 0)
}

func (s *JoinOpFullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterJoinOpFull(s)
	}
}

func (s *JoinOpFullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitJoinOpFull(s)
	}
}

func (s *JoinOpFullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitJoinOpFull(s)

	default:
		return t.VisitChildren(s)
	}
}

type JoinOpInnerContext struct {
	JoinOpContext
}

func NewJoinOpInnerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinOpInnerContext {
	var p = new(JoinOpInnerContext)

	InitEmptyJoinOpContext(&p.JoinOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinOpContext))

	return p
}

func (s *JoinOpInnerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpInnerContext) INNER() antlr.TerminalNode {
	return s.GetToken(DPParserINNER, 0)
}

func (s *JoinOpInnerContext) ALL() antlr.TerminalNode {
	return s.GetToken(DPParserALL, 0)
}

func (s *JoinOpInnerContext) ANY() antlr.TerminalNode {
	return s.GetToken(DPParserANY, 0)
}

func (s *JoinOpInnerContext) ASOF() antlr.TerminalNode {
	return s.GetToken(DPParserASOF, 0)
}

func (s *JoinOpInnerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterJoinOpInner(s)
	}
}

func (s *JoinOpInnerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitJoinOpInner(s)
	}
}

func (s *JoinOpInnerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitJoinOpInner(s)

	default:
		return t.VisitChildren(s)
	}
}

type JoinOpLeftRightContext struct {
	JoinOpContext
}

func NewJoinOpLeftRightContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinOpLeftRightContext {
	var p = new(JoinOpLeftRightContext)

	InitEmptyJoinOpContext(&p.JoinOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinOpContext))

	return p
}

func (s *JoinOpLeftRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpLeftRightContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DPParserLEFT, 0)
}

func (s *JoinOpLeftRightContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DPParserRIGHT, 0)
}

func (s *JoinOpLeftRightContext) OUTER() antlr.TerminalNode {
	return s.GetToken(DPParserOUTER, 0)
}

func (s *JoinOpLeftRightContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DPParserSEMI, 0)
}

func (s *JoinOpLeftRightContext) ALL() antlr.TerminalNode {
	return s.GetToken(DPParserALL, 0)
}

func (s *JoinOpLeftRightContext) ANTI() antlr.TerminalNode {
	return s.GetToken(DPParserANTI, 0)
}

func (s *JoinOpLeftRightContext) ANY() antlr.TerminalNode {
	return s.GetToken(DPParserANY, 0)
}

func (s *JoinOpLeftRightContext) ASOF() antlr.TerminalNode {
	return s.GetToken(DPParserASOF, 0)
}

func (s *JoinOpLeftRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterJoinOpLeftRight(s)
	}
}

func (s *JoinOpLeftRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitJoinOpLeftRight(s)
	}
}

func (s *JoinOpLeftRightContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitJoinOpLeftRight(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) JoinOp() (localctx IJoinOpContext) {
	localctx = NewJoinOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, DPParserRULE_joinOp)
	var _la int

	p.SetState(390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		localctx = NewJoinOpInnerContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(356)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
		case 1:
			p.SetState(348)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4368) != 0 {
				{
					p.SetState(347)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4368) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(350)
				p.Match(DPParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(351)
				p.Match(DPParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(353)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4368) != 0 {
				{
					p.SetState(352)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4368) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		case 3:
			{
				p.SetState(355)
				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4368) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		localctx = NewJoinOpLeftRightContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(372)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
		case 1:
			p.SetState(359)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4496) != 0) || _la == DPParserSEMI {
				{
					p.SetState(358)
					_la = p.GetTokenStream().LA(1)

					if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4496) != 0) || _la == DPParserSEMI) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(361)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DPParserLEFT || _la == DPParserRIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(363)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DPParserOUTER {
				{
					p.SetState(362)
					p.Match(DPParserOUTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case 2:
			{
				p.SetState(365)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DPParserLEFT || _la == DPParserRIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(367)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DPParserOUTER {
				{
					p.SetState(366)
					p.Match(DPParserOUTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(370)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4496) != 0) || _la == DPParserSEMI {
				{
					p.SetState(369)
					_la = p.GetTokenStream().LA(1)

					if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4496) != 0) || _la == DPParserSEMI) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 3:
		localctx = NewJoinOpFullContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) {
		case 1:
			p.SetState(375)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DPParserALL || _la == DPParserANY {
				{
					p.SetState(374)
					_la = p.GetTokenStream().LA(1)

					if !(_la == DPParserALL || _la == DPParserANY) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(377)
				p.Match(DPParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(379)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DPParserOUTER {
				{
					p.SetState(378)
					p.Match(DPParserOUTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case 2:
			{
				p.SetState(381)
				p.Match(DPParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(383)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DPParserOUTER {
				{
					p.SetState(382)
					p.Match(DPParserOUTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(386)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DPParserALL || _la == DPParserANY {
				{
					p.SetState(385)
					_la = p.GetTokenStream().LA(1)

					if !(_la == DPParserALL || _la == DPParserANY) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinOpCrossContext is an interface to support dynamic dispatch.
type IJoinOpCrossContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CROSS() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsJoinOpCrossContext differentiates from other interfaces.
	IsJoinOpCrossContext()
}

type JoinOpCrossContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinOpCrossContext() *JoinOpCrossContext {
	var p = new(JoinOpCrossContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_joinOpCross
	return p
}

func InitEmptyJoinOpCrossContext(p *JoinOpCrossContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_joinOpCross
}

func (*JoinOpCrossContext) IsJoinOpCrossContext() {}

func NewJoinOpCrossContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinOpCrossContext {
	var p = new(JoinOpCrossContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_joinOpCross

	return p
}

func (s *JoinOpCrossContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinOpCrossContext) CROSS() antlr.TerminalNode {
	return s.GetToken(DPParserCROSS, 0)
}

func (s *JoinOpCrossContext) JOIN() antlr.TerminalNode {
	return s.GetToken(DPParserJOIN, 0)
}

func (s *JoinOpCrossContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DPParserGLOBAL, 0)
}

func (s *JoinOpCrossContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DPParserLOCAL, 0)
}

func (s *JoinOpCrossContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, 0)
}

func (s *JoinOpCrossContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpCrossContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinOpCrossContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterJoinOpCross(s)
	}
}

func (s *JoinOpCrossContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitJoinOpCross(s)
	}
}

func (s *JoinOpCrossContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitJoinOpCross(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) JoinOpCross() (localctx IJoinOpCrossContext) {
	localctx = NewJoinOpCrossContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, DPParserRULE_joinOpCross)
	var _la int

	p.SetState(398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DPParserCROSS, DPParserGLOBAL, DPParserLOCAL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DPParserGLOBAL || _la == DPParserLOCAL {
			{
				p.SetState(392)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DPParserGLOBAL || _la == DPParserLOCAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(395)
			p.Match(DPParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(396)
			p.Match(DPParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DPParserCOMMA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(397)
			p.Match(DPParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinConstraintClauseContext is an interface to support dynamic dispatch.
type IJoinConstraintClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext
	USING() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsJoinConstraintClauseContext differentiates from other interfaces.
	IsJoinConstraintClauseContext()
}

type JoinConstraintClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinConstraintClauseContext() *JoinConstraintClauseContext {
	var p = new(JoinConstraintClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_joinConstraintClause
	return p
}

func InitEmptyJoinConstraintClauseContext(p *JoinConstraintClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_joinConstraintClause
}

func (*JoinConstraintClauseContext) IsJoinConstraintClauseContext() {}

func NewJoinConstraintClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinConstraintClauseContext {
	var p = new(JoinConstraintClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_joinConstraintClause

	return p
}

func (s *JoinConstraintClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinConstraintClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DPParserON, 0)
}

func (s *JoinConstraintClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *JoinConstraintClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(DPParserUSING, 0)
}

func (s *JoinConstraintClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *JoinConstraintClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *JoinConstraintClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinConstraintClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinConstraintClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterJoinConstraintClause(s)
	}
}

func (s *JoinConstraintClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitJoinConstraintClause(s)
	}
}

func (s *JoinConstraintClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitJoinConstraintClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) JoinConstraintClause() (localctx IJoinConstraintClauseContext) {
	localctx = NewJoinConstraintClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, DPParserRULE_joinConstraintClause)
	p.SetState(409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(400)
			p.Match(DPParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(401)
			p.ColumnExprList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(402)
			p.Match(DPParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(403)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(404)
			p.ColumnExprList()
		}
		{
			p.SetState(405)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(407)
			p.Match(DPParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(408)
			p.ColumnExprList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleClauseContext is an interface to support dynamic dispatch.
type ISampleClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAMPLE() antlr.TerminalNode
	AllRatioExpr() []IRatioExprContext
	RatioExpr(i int) IRatioExprContext
	OFFSET() antlr.TerminalNode

	// IsSampleClauseContext differentiates from other interfaces.
	IsSampleClauseContext()
}

type SampleClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleClauseContext() *SampleClauseContext {
	var p = new(SampleClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_sampleClause
	return p
}

func InitEmptySampleClauseContext(p *SampleClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_sampleClause
}

func (*SampleClauseContext) IsSampleClauseContext() {}

func NewSampleClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleClauseContext {
	var p = new(SampleClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_sampleClause

	return p
}

func (s *SampleClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DPParserSAMPLE, 0)
}

func (s *SampleClauseContext) AllRatioExpr() []IRatioExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRatioExprContext); ok {
			len++
		}
	}

	tst := make([]IRatioExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRatioExprContext); ok {
			tst[i] = t.(IRatioExprContext)
			i++
		}
	}

	return tst
}

func (s *SampleClauseContext) RatioExpr(i int) IRatioExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRatioExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRatioExprContext)
}

func (s *SampleClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DPParserOFFSET, 0)
}

func (s *SampleClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterSampleClause(s)
	}
}

func (s *SampleClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitSampleClause(s)
	}
}

func (s *SampleClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitSampleClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) SampleClause() (localctx ISampleClauseContext) {
	localctx = NewSampleClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, DPParserRULE_sampleClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(411)
		p.Match(DPParserSAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(412)
		p.RatioExpr()
	}
	p.SetState(415)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(413)
			p.Match(DPParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(414)
			p.RatioExpr()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitExprContext is an interface to support dynamic dispatch.
type ILimitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnExpr() []IColumnExprContext
	ColumnExpr(i int) IColumnExprContext
	COMMA() antlr.TerminalNode
	OFFSET() antlr.TerminalNode

	// IsLimitExprContext differentiates from other interfaces.
	IsLimitExprContext()
}

type LimitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitExprContext() *LimitExprContext {
	var p = new(LimitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_limitExpr
	return p
}

func InitEmptyLimitExprContext(p *LimitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_limitExpr
}

func (*LimitExprContext) IsLimitExprContext() {}

func NewLimitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitExprContext {
	var p = new(LimitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_limitExpr

	return p
}

func (s *LimitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitExprContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *LimitExprContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *LimitExprContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, 0)
}

func (s *LimitExprContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DPParserOFFSET, 0)
}

func (s *LimitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterLimitExpr(s)
	}
}

func (s *LimitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitLimitExpr(s)
	}
}

func (s *LimitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitLimitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) LimitExpr() (localctx ILimitExprContext) {
	localctx = NewLimitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, DPParserRULE_limitExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(417)
		p.columnExpr(0)
	}
	p.SetState(420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserOFFSET || _la == DPParserCOMMA {
		{
			p.SetState(418)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DPParserOFFSET || _la == DPParserCOMMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(419)
			p.columnExpr(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITealimitExprContext is an interface to support dynamic dispatch.
type ITealimitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumberLiteral() INumberLiteralContext
	GROUP() antlr.TerminalNode

	// IsTealimitExprContext differentiates from other interfaces.
	IsTealimitExprContext()
}

type TealimitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTealimitExprContext() *TealimitExprContext {
	var p = new(TealimitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tealimitExpr
	return p
}

func InitEmptyTealimitExprContext(p *TealimitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tealimitExpr
}

func (*TealimitExprContext) IsTealimitExprContext() {}

func NewTealimitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TealimitExprContext {
	var p = new(TealimitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_tealimitExpr

	return p
}

func (s *TealimitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TealimitExprContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *TealimitExprContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DPParserGROUP, 0)
}

func (s *TealimitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TealimitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TealimitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterTealimitExpr(s)
	}
}

func (s *TealimitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitTealimitExpr(s)
	}
}

func (s *TealimitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitTealimitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) TealimitExpr() (localctx ITealimitExprContext) {
	localctx = NewTealimitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, DPParserRULE_tealimitExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(422)
		p.NumberLiteral()
	}
	{
		p.SetState(423)
		p.Match(DPParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderExprListContext is an interface to support dynamic dispatch.
type IOrderExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOrderExpr() []IOrderExprContext
	OrderExpr(i int) IOrderExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrderExprListContext differentiates from other interfaces.
	IsOrderExprListContext()
}

type OrderExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderExprListContext() *OrderExprListContext {
	var p = new(OrderExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_orderExprList
	return p
}

func InitEmptyOrderExprListContext(p *OrderExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_orderExprList
}

func (*OrderExprListContext) IsOrderExprListContext() {}

func NewOrderExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderExprListContext {
	var p = new(OrderExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_orderExprList

	return p
}

func (s *OrderExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderExprListContext) AllOrderExpr() []IOrderExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderExprContext); ok {
			len++
		}
	}

	tst := make([]IOrderExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderExprContext); ok {
			tst[i] = t.(IOrderExprContext)
			i++
		}
	}

	return tst
}

func (s *OrderExprListContext) OrderExpr(i int) IOrderExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderExprContext)
}

func (s *OrderExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DPParserCOMMA)
}

func (s *OrderExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, i)
}

func (s *OrderExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterOrderExprList(s)
	}
}

func (s *OrderExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitOrderExprList(s)
	}
}

func (s *OrderExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitOrderExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) OrderExprList() (localctx IOrderExprListContext) {
	localctx = NewOrderExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, DPParserRULE_orderExprList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(425)
		p.OrderExpr()
	}
	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DPParserCOMMA {
		{
			p.SetState(426)
			p.Match(DPParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(427)
			p.OrderExpr()
		}

		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderExprContext is an interface to support dynamic dispatch.
type IOrderExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnExpr() IColumnExprContext
	NULLS() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ASCENDING() antlr.TerminalNode
	DESCENDING() antlr.TerminalNode
	DESC() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsOrderExprContext differentiates from other interfaces.
	IsOrderExprContext()
}

type OrderExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderExprContext() *OrderExprContext {
	var p = new(OrderExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_orderExpr
	return p
}

func InitEmptyOrderExprContext(p *OrderExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_orderExpr
}

func (*OrderExprContext) IsOrderExprContext() {}

func NewOrderExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderExprContext {
	var p = new(OrderExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_orderExpr

	return p
}

func (s *OrderExprContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderExprContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *OrderExprContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DPParserNULLS, 0)
}

func (s *OrderExprContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DPParserCOLLATE, 0)
}

func (s *OrderExprContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserSTRING_LITERAL, 0)
}

func (s *OrderExprContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(DPParserASCENDING, 0)
}

func (s *OrderExprContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(DPParserDESCENDING, 0)
}

func (s *OrderExprContext) DESC() antlr.TerminalNode {
	return s.GetToken(DPParserDESC, 0)
}

func (s *OrderExprContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DPParserFIRST, 0)
}

func (s *OrderExprContext) LAST() antlr.TerminalNode {
	return s.GetToken(DPParserLAST, 0)
}

func (s *OrderExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterOrderExpr(s)
	}
}

func (s *OrderExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitOrderExpr(s)
	}
}

func (s *OrderExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitOrderExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) OrderExpr() (localctx IOrderExprContext) {
	localctx = NewOrderExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, DPParserRULE_orderExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(433)
		p.columnExpr(0)
	}
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6597069768704) != 0 {
		{
			p.SetState(434)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6597069768704) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserNULLS {
		{
			p.SetState(437)
			p.Match(DPParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(438)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DPParserFIRST || _la == DPParserLAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserCOLLATE {
		{
			p.SetState(441)
			p.Match(DPParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(442)
			p.Match(DPParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRatioExprContext is an interface to support dynamic dispatch.
type IRatioExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNumberLiteral() []INumberLiteralContext
	NumberLiteral(i int) INumberLiteralContext
	SLASH() antlr.TerminalNode

	// IsRatioExprContext differentiates from other interfaces.
	IsRatioExprContext()
}

type RatioExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRatioExprContext() *RatioExprContext {
	var p = new(RatioExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_ratioExpr
	return p
}

func InitEmptyRatioExprContext(p *RatioExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_ratioExpr
}

func (*RatioExprContext) IsRatioExprContext() {}

func NewRatioExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RatioExprContext {
	var p = new(RatioExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_ratioExpr

	return p
}

func (s *RatioExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RatioExprContext) AllNumberLiteral() []INumberLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumberLiteralContext); ok {
			len++
		}
	}

	tst := make([]INumberLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumberLiteralContext); ok {
			tst[i] = t.(INumberLiteralContext)
			i++
		}
	}

	return tst
}

func (s *RatioExprContext) NumberLiteral(i int) INumberLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *RatioExprContext) SLASH() antlr.TerminalNode {
	return s.GetToken(DPParserSLASH, 0)
}

func (s *RatioExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RatioExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RatioExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterRatioExpr(s)
	}
}

func (s *RatioExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitRatioExpr(s)
	}
}

func (s *RatioExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitRatioExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) RatioExpr() (localctx IRatioExprContext) {
	localctx = NewRatioExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, DPParserRULE_ratioExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		p.NumberLiteral()
	}
	p.SetState(448)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(446)
			p.Match(DPParserSLASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(447)
			p.NumberLiteral()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISettingExprListContext is an interface to support dynamic dispatch.
type ISettingExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSettingExpr() []ISettingExprContext
	SettingExpr(i int) ISettingExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSettingExprListContext differentiates from other interfaces.
	IsSettingExprListContext()
}

type SettingExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySettingExprListContext() *SettingExprListContext {
	var p = new(SettingExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_settingExprList
	return p
}

func InitEmptySettingExprListContext(p *SettingExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_settingExprList
}

func (*SettingExprListContext) IsSettingExprListContext() {}

func NewSettingExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SettingExprListContext {
	var p = new(SettingExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_settingExprList

	return p
}

func (s *SettingExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *SettingExprListContext) AllSettingExpr() []ISettingExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISettingExprContext); ok {
			len++
		}
	}

	tst := make([]ISettingExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISettingExprContext); ok {
			tst[i] = t.(ISettingExprContext)
			i++
		}
	}

	return tst
}

func (s *SettingExprListContext) SettingExpr(i int) ISettingExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISettingExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISettingExprContext)
}

func (s *SettingExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DPParserCOMMA)
}

func (s *SettingExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, i)
}

func (s *SettingExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SettingExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SettingExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterSettingExprList(s)
	}
}

func (s *SettingExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitSettingExprList(s)
	}
}

func (s *SettingExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitSettingExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) SettingExprList() (localctx ISettingExprListContext) {
	localctx = NewSettingExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, DPParserRULE_settingExprList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(450)
		p.SettingExpr()
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DPParserCOMMA {
		{
			p.SetState(451)
			p.Match(DPParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(452)
			p.SettingExpr()
		}

		p.SetState(457)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISettingExprContext is an interface to support dynamic dispatch.
type ISettingExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ_SINGLE() antlr.TerminalNode
	Literal() ILiteralContext

	// IsSettingExprContext differentiates from other interfaces.
	IsSettingExprContext()
}

type SettingExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySettingExprContext() *SettingExprContext {
	var p = new(SettingExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_settingExpr
	return p
}

func InitEmptySettingExprContext(p *SettingExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_settingExpr
}

func (*SettingExprContext) IsSettingExprContext() {}

func NewSettingExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SettingExprContext {
	var p = new(SettingExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_settingExpr

	return p
}

func (s *SettingExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SettingExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SettingExprContext) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(DPParserEQ_SINGLE, 0)
}

func (s *SettingExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SettingExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SettingExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SettingExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterSettingExpr(s)
	}
}

func (s *SettingExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitSettingExpr(s)
	}
}

func (s *SettingExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitSettingExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) SettingExpr() (localctx ISettingExprContext) {
	localctx = NewSettingExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, DPParserRULE_settingExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.Identifier()
	}
	{
		p.SetState(459)
		p.Match(DPParserEQ_SINGLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(460)
		p.Literal()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowExprContext is an interface to support dynamic dispatch.
type IWindowExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WinPartitionByClause() IWinPartitionByClauseContext
	WinOrderByClause() IWinOrderByClauseContext
	WinFrameClause() IWinFrameClauseContext

	// IsWindowExprContext differentiates from other interfaces.
	IsWindowExprContext()
}

type WindowExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowExprContext() *WindowExprContext {
	var p = new(WindowExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_windowExpr
	return p
}

func InitEmptyWindowExprContext(p *WindowExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_windowExpr
}

func (*WindowExprContext) IsWindowExprContext() {}

func NewWindowExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowExprContext {
	var p = new(WindowExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_windowExpr

	return p
}

func (s *WindowExprContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowExprContext) WinPartitionByClause() IWinPartitionByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWinPartitionByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWinPartitionByClauseContext)
}

func (s *WindowExprContext) WinOrderByClause() IWinOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWinOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWinOrderByClauseContext)
}

func (s *WindowExprContext) WinFrameClause() IWinFrameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWinFrameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWinFrameClauseContext)
}

func (s *WindowExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterWindowExpr(s)
	}
}

func (s *WindowExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitWindowExpr(s)
	}
}

func (s *WindowExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitWindowExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) WindowExpr() (localctx IWindowExprContext) {
	localctx = NewWindowExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, DPParserRULE_windowExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserPARTITION {
		{
			p.SetState(462)
			p.WinPartitionByClause()
		}

	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserORDER {
		{
			p.SetState(465)
			p.WinOrderByClause()
		}

	}
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserRANGE || _la == DPParserROWS {
		{
			p.SetState(468)
			p.WinFrameClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWinPartitionByClauseContext is an interface to support dynamic dispatch.
type IWinPartitionByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext

	// IsWinPartitionByClauseContext differentiates from other interfaces.
	IsWinPartitionByClauseContext()
}

type WinPartitionByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWinPartitionByClauseContext() *WinPartitionByClauseContext {
	var p = new(WinPartitionByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_winPartitionByClause
	return p
}

func InitEmptyWinPartitionByClauseContext(p *WinPartitionByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_winPartitionByClause
}

func (*WinPartitionByClauseContext) IsWinPartitionByClauseContext() {}

func NewWinPartitionByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WinPartitionByClauseContext {
	var p = new(WinPartitionByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_winPartitionByClause

	return p
}

func (s *WinPartitionByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WinPartitionByClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DPParserPARTITION, 0)
}

func (s *WinPartitionByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DPParserBY, 0)
}

func (s *WinPartitionByClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *WinPartitionByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WinPartitionByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WinPartitionByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterWinPartitionByClause(s)
	}
}

func (s *WinPartitionByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitWinPartitionByClause(s)
	}
}

func (s *WinPartitionByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitWinPartitionByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) WinPartitionByClause() (localctx IWinPartitionByClauseContext) {
	localctx = NewWinPartitionByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, DPParserRULE_winPartitionByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.Match(DPParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(472)
		p.Match(DPParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(473)
		p.ColumnExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWinOrderByClauseContext is an interface to support dynamic dispatch.
type IWinOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	OrderExprList() IOrderExprListContext

	// IsWinOrderByClauseContext differentiates from other interfaces.
	IsWinOrderByClauseContext()
}

type WinOrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWinOrderByClauseContext() *WinOrderByClauseContext {
	var p = new(WinOrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_winOrderByClause
	return p
}

func InitEmptyWinOrderByClauseContext(p *WinOrderByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_winOrderByClause
}

func (*WinOrderByClauseContext) IsWinOrderByClauseContext() {}

func NewWinOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WinOrderByClauseContext {
	var p = new(WinOrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_winOrderByClause

	return p
}

func (s *WinOrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WinOrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DPParserORDER, 0)
}

func (s *WinOrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DPParserBY, 0)
}

func (s *WinOrderByClauseContext) OrderExprList() IOrderExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderExprListContext)
}

func (s *WinOrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WinOrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WinOrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterWinOrderByClause(s)
	}
}

func (s *WinOrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitWinOrderByClause(s)
	}
}

func (s *WinOrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitWinOrderByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) WinOrderByClause() (localctx IWinOrderByClauseContext) {
	localctx = NewWinOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, DPParserRULE_winOrderByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(475)
		p.Match(DPParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(476)
		p.Match(DPParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(477)
		p.OrderExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWinFrameClauseContext is an interface to support dynamic dispatch.
type IWinFrameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WinFrameExtend() IWinFrameExtendContext
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode

	// IsWinFrameClauseContext differentiates from other interfaces.
	IsWinFrameClauseContext()
}

type WinFrameClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWinFrameClauseContext() *WinFrameClauseContext {
	var p = new(WinFrameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_winFrameClause
	return p
}

func InitEmptyWinFrameClauseContext(p *WinFrameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_winFrameClause
}

func (*WinFrameClauseContext) IsWinFrameClauseContext() {}

func NewWinFrameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WinFrameClauseContext {
	var p = new(WinFrameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_winFrameClause

	return p
}

func (s *WinFrameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WinFrameClauseContext) WinFrameExtend() IWinFrameExtendContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWinFrameExtendContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWinFrameExtendContext)
}

func (s *WinFrameClauseContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DPParserROWS, 0)
}

func (s *WinFrameClauseContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DPParserRANGE, 0)
}

func (s *WinFrameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WinFrameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WinFrameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterWinFrameClause(s)
	}
}

func (s *WinFrameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitWinFrameClause(s)
	}
}

func (s *WinFrameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitWinFrameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) WinFrameClause() (localctx IWinFrameClauseContext) {
	localctx = NewWinFrameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, DPParserRULE_winFrameClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(479)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DPParserRANGE || _la == DPParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(480)
		p.WinFrameExtend()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWinFrameExtendContext is an interface to support dynamic dispatch.
type IWinFrameExtendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWinFrameExtendContext differentiates from other interfaces.
	IsWinFrameExtendContext()
}

type WinFrameExtendContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWinFrameExtendContext() *WinFrameExtendContext {
	var p = new(WinFrameExtendContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_winFrameExtend
	return p
}

func InitEmptyWinFrameExtendContext(p *WinFrameExtendContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_winFrameExtend
}

func (*WinFrameExtendContext) IsWinFrameExtendContext() {}

func NewWinFrameExtendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WinFrameExtendContext {
	var p = new(WinFrameExtendContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_winFrameExtend

	return p
}

func (s *WinFrameExtendContext) GetParser() antlr.Parser { return s.parser }

func (s *WinFrameExtendContext) CopyAll(ctx *WinFrameExtendContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *WinFrameExtendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WinFrameExtendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type FrameStartContext struct {
	WinFrameExtendContext
}

func NewFrameStartContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FrameStartContext {
	var p = new(FrameStartContext)

	InitEmptyWinFrameExtendContext(&p.WinFrameExtendContext)
	p.parser = parser
	p.CopyAll(ctx.(*WinFrameExtendContext))

	return p
}

func (s *FrameStartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameStartContext) WinFrameBound() IWinFrameBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWinFrameBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWinFrameBoundContext)
}

func (s *FrameStartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterFrameStart(s)
	}
}

func (s *FrameStartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitFrameStart(s)
	}
}

func (s *FrameStartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitFrameStart(s)

	default:
		return t.VisitChildren(s)
	}
}

type FrameBetweenContext struct {
	WinFrameExtendContext
}

func NewFrameBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FrameBetweenContext {
	var p = new(FrameBetweenContext)

	InitEmptyWinFrameExtendContext(&p.WinFrameExtendContext)
	p.parser = parser
	p.CopyAll(ctx.(*WinFrameExtendContext))

	return p
}

func (s *FrameBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DPParserBETWEEN, 0)
}

func (s *FrameBetweenContext) AllWinFrameBound() []IWinFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWinFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IWinFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWinFrameBoundContext); ok {
			tst[i] = t.(IWinFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *FrameBetweenContext) WinFrameBound(i int) IWinFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWinFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWinFrameBoundContext)
}

func (s *FrameBetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(DPParserAND, 0)
}

func (s *FrameBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterFrameBetween(s)
	}
}

func (s *FrameBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitFrameBetween(s)
	}
}

func (s *FrameBetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitFrameBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) WinFrameExtend() (localctx IWinFrameExtendContext) {
	localctx = NewWinFrameExtendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, DPParserRULE_winFrameExtend)
	p.SetState(488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DPParserCURRENT, DPParserINF, DPParserNAN_SQL, DPParserUNBOUNDED, DPParserFLOATING_LITERAL, DPParserOCTAL_LITERAL, DPParserDECIMAL_LITERAL, DPParserHEXADECIMAL_LITERAL, DPParserDASH, DPParserDOT, DPParserPLUS:
		localctx = NewFrameStartContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(482)
			p.WinFrameBound()
		}

	case DPParserBETWEEN:
		localctx = NewFrameBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(483)
			p.Match(DPParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(484)
			p.WinFrameBound()
		}
		{
			p.SetState(485)
			p.Match(DPParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(486)
			p.WinFrameBound()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWinFrameBoundContext is an interface to support dynamic dispatch.
type IWinFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	NumberLiteral() INumberLiteralContext

	// IsWinFrameBoundContext differentiates from other interfaces.
	IsWinFrameBoundContext()
}

type WinFrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWinFrameBoundContext() *WinFrameBoundContext {
	var p = new(WinFrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_winFrameBound
	return p
}

func InitEmptyWinFrameBoundContext(p *WinFrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_winFrameBound
}

func (*WinFrameBoundContext) IsWinFrameBoundContext() {}

func NewWinFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WinFrameBoundContext {
	var p = new(WinFrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_winFrameBound

	return p
}

func (s *WinFrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *WinFrameBoundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(DPParserCURRENT, 0)
}

func (s *WinFrameBoundContext) ROW() antlr.TerminalNode {
	return s.GetToken(DPParserROW, 0)
}

func (s *WinFrameBoundContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DPParserUNBOUNDED, 0)
}

func (s *WinFrameBoundContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DPParserPRECEDING, 0)
}

func (s *WinFrameBoundContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(DPParserFOLLOWING, 0)
}

func (s *WinFrameBoundContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *WinFrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WinFrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WinFrameBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterWinFrameBound(s)
	}
}

func (s *WinFrameBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitWinFrameBound(s)
	}
}

func (s *WinFrameBoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitWinFrameBound(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) WinFrameBound() (localctx IWinFrameBoundContext) {
	localctx = NewWinFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, DPParserRULE_winFrameBound)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(490)
			p.Match(DPParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(491)
			p.Match(DPParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(492)
			p.Match(DPParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(493)
			p.Match(DPParserPRECEDING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(494)
			p.Match(DPParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(495)
			p.Match(DPParserFOLLOWING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(496)
			p.NumberLiteral()
		}
		{
			p.SetState(497)
			p.Match(DPParserPRECEDING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(499)
			p.NumberLiteral()
		}
		{
			p.SetState(500)
			p.Match(DPParserFOLLOWING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnTypeExprContext is an interface to support dynamic dispatch.
type IColumnTypeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsColumnTypeExprContext differentiates from other interfaces.
	IsColumnTypeExprContext()
}

type ColumnTypeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnTypeExprContext() *ColumnTypeExprContext {
	var p = new(ColumnTypeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnTypeExpr
	return p
}

func InitEmptyColumnTypeExprContext(p *ColumnTypeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnTypeExpr
}

func (*ColumnTypeExprContext) IsColumnTypeExprContext() {}

func NewColumnTypeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnTypeExprContext {
	var p = new(ColumnTypeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_columnTypeExpr

	return p
}

func (s *ColumnTypeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnTypeExprContext) CopyAll(ctx *ColumnTypeExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ColumnTypeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnTypeExprNestedContext struct {
	ColumnTypeExprContext
}

func NewColumnTypeExprNestedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprNestedContext {
	var p = new(ColumnTypeExprNestedContext)

	InitEmptyColumnTypeExprContext(&p.ColumnTypeExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprNestedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprNestedContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnTypeExprNestedContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprNestedContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnTypeExprNestedContext) AllColumnTypeExpr() []IColumnTypeExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnTypeExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnTypeExprContext); ok {
			tst[i] = t.(IColumnTypeExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnTypeExprNestedContext) ColumnTypeExpr(i int) IColumnTypeExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *ColumnTypeExprNestedContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnTypeExprNestedContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DPParserCOMMA)
}

func (s *ColumnTypeExprNestedContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, i)
}

func (s *ColumnTypeExprNestedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnTypeExprNested(s)
	}
}

func (s *ColumnTypeExprNestedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnTypeExprNested(s)
	}
}

func (s *ColumnTypeExprNestedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnTypeExprNested(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnTypeExprParamContext struct {
	ColumnTypeExprContext
}

func NewColumnTypeExprParamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprParamContext {
	var p = new(ColumnTypeExprParamContext)

	InitEmptyColumnTypeExprContext(&p.ColumnTypeExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprParamContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprParamContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnTypeExprParamContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnTypeExprParamContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnTypeExprParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnTypeExprParam(s)
	}
}

func (s *ColumnTypeExprParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnTypeExprParam(s)
	}
}

func (s *ColumnTypeExprParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnTypeExprParam(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnTypeExprSimpleContext struct {
	ColumnTypeExprContext
}

func NewColumnTypeExprSimpleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprSimpleContext {
	var p = new(ColumnTypeExprSimpleContext)

	InitEmptyColumnTypeExprContext(&p.ColumnTypeExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprSimpleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnTypeExprSimple(s)
	}
}

func (s *ColumnTypeExprSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnTypeExprSimple(s)
	}
}

func (s *ColumnTypeExprSimpleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnTypeExprSimple(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnTypeExprComplexContext struct {
	ColumnTypeExprContext
}

func NewColumnTypeExprComplexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprComplexContext {
	var p = new(ColumnTypeExprComplexContext)

	InitEmptyColumnTypeExprContext(&p.ColumnTypeExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprComplexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprComplexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprComplexContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnTypeExprComplexContext) AllColumnTypeExpr() []IColumnTypeExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnTypeExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnTypeExprContext); ok {
			tst[i] = t.(IColumnTypeExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnTypeExprComplexContext) ColumnTypeExpr(i int) IColumnTypeExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *ColumnTypeExprComplexContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnTypeExprComplexContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DPParserCOMMA)
}

func (s *ColumnTypeExprComplexContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, i)
}

func (s *ColumnTypeExprComplexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnTypeExprComplex(s)
	}
}

func (s *ColumnTypeExprComplexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnTypeExprComplex(s)
	}
}

func (s *ColumnTypeExprComplexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnTypeExprComplex(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnTypeExprEnumContext struct {
	ColumnTypeExprContext
}

func NewColumnTypeExprEnumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprEnumContext {
	var p = new(ColumnTypeExprEnumContext)

	InitEmptyColumnTypeExprContext(&p.ColumnTypeExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprEnumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprEnumContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprEnumContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnTypeExprEnumContext) AllEnumValue() []IEnumValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumValueContext); ok {
			len++
		}
	}

	tst := make([]IEnumValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumValueContext); ok {
			tst[i] = t.(IEnumValueContext)
			i++
		}
	}

	return tst
}

func (s *ColumnTypeExprEnumContext) EnumValue(i int) IEnumValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueContext)
}

func (s *ColumnTypeExprEnumContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnTypeExprEnumContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DPParserCOMMA)
}

func (s *ColumnTypeExprEnumContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, i)
}

func (s *ColumnTypeExprEnumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnTypeExprEnum(s)
	}
}

func (s *ColumnTypeExprEnumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnTypeExprEnum(s)
	}
}

func (s *ColumnTypeExprEnumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnTypeExprEnum(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) ColumnTypeExpr() (localctx IColumnTypeExprContext) {
	localctx = NewColumnTypeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, DPParserRULE_columnTypeExpr)
	var _la int

	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnTypeExprSimpleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(504)
			p.Identifier()
		}

	case 2:
		localctx = NewColumnTypeExprNestedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(505)
			p.Identifier()
		}
		{
			p.SetState(506)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(507)
			p.Identifier()
		}
		{
			p.SetState(508)
			p.ColumnTypeExpr()
		}
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DPParserCOMMA {
			{
				p.SetState(509)
				p.Match(DPParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(510)
				p.Identifier()
			}
			{
				p.SetState(511)
				p.ColumnTypeExpr()
			}

			p.SetState(517)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(518)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewColumnTypeExprEnumContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(520)
			p.Identifier()
		}
		{
			p.SetState(521)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(522)
			p.EnumValue()
		}
		p.SetState(527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DPParserCOMMA {
			{
				p.SetState(523)
				p.Match(DPParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(524)
				p.EnumValue()
			}

			p.SetState(529)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(530)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewColumnTypeExprComplexContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(532)
			p.Identifier()
		}
		{
			p.SetState(533)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(534)
			p.ColumnTypeExpr()
		}
		p.SetState(539)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DPParserCOMMA {
			{
				p.SetState(535)
				p.Match(DPParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(536)
				p.ColumnTypeExpr()
			}

			p.SetState(541)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(542)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewColumnTypeExprParamContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(544)
			p.Identifier()
		}
		{
			p.SetState(545)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4294967301) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&144753023) != 0) {
			{
				p.SetState(546)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(549)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnExprListContext is an interface to support dynamic dispatch.
type IColumnExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnsExpr() []IColumnsExprContext
	ColumnsExpr(i int) IColumnsExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnExprListContext differentiates from other interfaces.
	IsColumnExprListContext()
}

type ColumnExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnExprListContext() *ColumnExprListContext {
	var p = new(ColumnExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnExprList
	return p
}

func InitEmptyColumnExprListContext(p *ColumnExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnExprList
}

func (*ColumnExprListContext) IsColumnExprListContext() {}

func NewColumnExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnExprListContext {
	var p = new(ColumnExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_columnExprList

	return p
}

func (s *ColumnExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnExprListContext) AllColumnsExpr() []IColumnsExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnsExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnsExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnsExprContext); ok {
			tst[i] = t.(IColumnsExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprListContext) ColumnsExpr(i int) IColumnsExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsExprContext)
}

func (s *ColumnExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DPParserCOMMA)
}

func (s *ColumnExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, i)
}

func (s *ColumnExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprList(s)
	}
}

func (s *ColumnExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprList(s)
	}
}

func (s *ColumnExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) ColumnExprList() (localctx IColumnExprListContext) {
	localctx = NewColumnExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, DPParserRULE_columnExprList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.ColumnsExpr()
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(554)
				p.Match(DPParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(555)
				p.ColumnsExpr()
			}

		}
		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnsExprContext is an interface to support dynamic dispatch.
type IColumnsExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsColumnsExprContext differentiates from other interfaces.
	IsColumnsExprContext()
}

type ColumnsExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnsExprContext() *ColumnsExprContext {
	var p = new(ColumnsExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnsExpr
	return p
}

func InitEmptyColumnsExprContext(p *ColumnsExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnsExpr
}

func (*ColumnsExprContext) IsColumnsExprContext() {}

func NewColumnsExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnsExprContext {
	var p = new(ColumnsExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_columnsExpr

	return p
}

func (s *ColumnsExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnsExprContext) CopyAll(ctx *ColumnsExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ColumnsExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnsExprColumnContext struct {
	ColumnsExprContext
}

func NewColumnsExprColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnsExprColumnContext {
	var p = new(ColumnsExprColumnContext)

	InitEmptyColumnsExprContext(&p.ColumnsExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnsExprContext))

	return p
}

func (s *ColumnsExprColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsExprColumnContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnsExprColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnsExprColumn(s)
	}
}

func (s *ColumnsExprColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnsExprColumn(s)
	}
}

func (s *ColumnsExprColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnsExprColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnsExprAsteriskContext struct {
	ColumnsExprContext
}

func NewColumnsExprAsteriskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnsExprAsteriskContext {
	var p = new(ColumnsExprAsteriskContext)

	InitEmptyColumnsExprContext(&p.ColumnsExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnsExprContext))

	return p
}

func (s *ColumnsExprAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsExprAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DPParserASTERISK, 0)
}

func (s *ColumnsExprAsteriskContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ColumnsExprAsteriskContext) DOT() antlr.TerminalNode {
	return s.GetToken(DPParserDOT, 0)
}

func (s *ColumnsExprAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnsExprAsterisk(s)
	}
}

func (s *ColumnsExprAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnsExprAsterisk(s)
	}
}

func (s *ColumnsExprAsteriskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnsExprAsterisk(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnsExprSubqueryContext struct {
	ColumnsExprContext
}

func NewColumnsExprSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnsExprSubqueryContext {
	var p = new(ColumnsExprSubqueryContext)

	InitEmptyColumnsExprContext(&p.ColumnsExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnsExprContext))

	return p
}

func (s *ColumnsExprSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsExprSubqueryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnsExprSubqueryContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *ColumnsExprSubqueryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnsExprSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnsExprSubquery(s)
	}
}

func (s *ColumnsExprSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnsExprSubquery(s)
	}
}

func (s *ColumnsExprSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnsExprSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) ColumnsExpr() (localctx IColumnsExprContext) {
	localctx = NewColumnsExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, DPParserRULE_columnsExpr)
	var _la int

	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnsExprAsteriskContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-2)) & ^0x3f) == 0 && ((int64(1)<<(_la-2))&-1) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-633318697631745) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&9223372036317904895) != 0) {
			{
				p.SetState(561)
				p.TableIdentifier()
			}
			{
				p.SetState(562)
				p.Match(DPParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(566)
			p.Match(DPParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewColumnsExprSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(567)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(568)
			p.SelectUnionStmt()
		}
		{
			p.SetState(569)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewColumnsExprColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(571)
			p.columnExpr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnExprContext is an interface to support dynamic dispatch.
type IColumnExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsColumnExprContext differentiates from other interfaces.
	IsColumnExprContext()
}

type ColumnExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnExprContext() *ColumnExprContext {
	var p = new(ColumnExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnExpr
	return p
}

func InitEmptyColumnExprContext(p *ColumnExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnExpr
}

func (*ColumnExprContext) IsColumnExprContext() {}

func NewColumnExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnExprContext {
	var p = new(ColumnExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_columnExpr

	return p
}

func (s *ColumnExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnExprContext) CopyAll(ctx *ColumnExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ColumnExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnExprTernaryOpContext struct {
	ColumnExprContext
}

func NewColumnExprTernaryOpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTernaryOpContext {
	var p = new(ColumnExprTernaryOpContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTernaryOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTernaryOpContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprTernaryOpContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprTernaryOpContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DPParserQUERY, 0)
}

func (s *ColumnExprTernaryOpContext) COLON() antlr.TerminalNode {
	return s.GetToken(DPParserCOLON, 0)
}

func (s *ColumnExprTernaryOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprTernaryOp(s)
	}
}

func (s *ColumnExprTernaryOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprTernaryOp(s)
	}
}

func (s *ColumnExprTernaryOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprTernaryOp(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprAliasContext struct {
	ColumnExprContext
}

func NewColumnExprAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprAliasContext {
	var p = new(ColumnExprAliasContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprAliasContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprAliasContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *ColumnExprAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(DPParserAS, 0)
}

func (s *ColumnExprAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnExprAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprAlias(s)
	}
}

func (s *ColumnExprAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprAlias(s)
	}
}

func (s *ColumnExprAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprExtractContext struct {
	ColumnExprContext
}

func NewColumnExprExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprExtractContext {
	var p = new(ColumnExprExtractContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(DPParserEXTRACT, 0)
}

func (s *ColumnExprExtractContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnExprExtractContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *ColumnExprExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(DPParserFROM, 0)
}

func (s *ColumnExprExtractContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprExtractContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnExprExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprExtract(s)
	}
}

func (s *ColumnExprExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprExtract(s)
	}
}

func (s *ColumnExprExtractContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprExtract(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprNegateContext struct {
	ColumnExprContext
}

func NewColumnExprNegateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprNegateContext {
	var p = new(ColumnExprNegateContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprNegateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprNegateContext) DASH() antlr.TerminalNode {
	return s.GetToken(DPParserDASH, 0)
}

func (s *ColumnExprNegateContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprNegateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprNegate(s)
	}
}

func (s *ColumnExprNegateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprNegate(s)
	}
}

func (s *ColumnExprNegateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprNegate(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprSubqueryContext struct {
	ColumnExprContext
}

func NewColumnExprSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprSubqueryContext {
	var p = new(ColumnExprSubqueryContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprSubqueryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnExprSubqueryContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *ColumnExprSubqueryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnExprSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprSubquery(s)
	}
}

func (s *ColumnExprSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprSubquery(s)
	}
}

func (s *ColumnExprSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprLiteralContext struct {
	ColumnExprContext
}

func NewColumnExprLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprLiteralContext {
	var p = new(ColumnExprLiteralContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprLiteralContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ColumnExprLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprLiteral(s)
	}
}

func (s *ColumnExprLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprLiteral(s)
	}
}

func (s *ColumnExprLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprBraceParamContext struct {
	ColumnExprContext
}

func NewColumnExprBraceParamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprBraceParamContext {
	var p = new(ColumnExprBraceParamContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprBraceParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprBraceParamContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DPParserIDENTIFIER, 0)
}

func (s *ColumnExprBraceParamContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(DPParserLBRACE, 0)
}

func (s *ColumnExprBraceParamContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ColumnExprBraceParamContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(DPParserRBRACE, 0)
}

func (s *ColumnExprBraceParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprBraceParam(s)
	}
}

func (s *ColumnExprBraceParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprBraceParam(s)
	}
}

func (s *ColumnExprBraceParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprBraceParam(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprArrayContext struct {
	ColumnExprContext
}

func NewColumnExprArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprArrayContext {
	var p = new(ColumnExprArrayContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprArrayContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(DPParserLBRACKET, 0)
}

func (s *ColumnExprArrayContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(DPParserRBRACKET, 0)
}

func (s *ColumnExprArrayContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprArray(s)
	}
}

func (s *ColumnExprArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprArray(s)
	}
}

func (s *ColumnExprArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprSubstringContext struct {
	ColumnExprContext
}

func NewColumnExprSubstringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprSubstringContext {
	var p = new(ColumnExprSubstringContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprSubstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprSubstringContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(DPParserSUBSTRING, 0)
}

func (s *ColumnExprSubstringContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnExprSubstringContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprSubstringContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprSubstringContext) FROM() antlr.TerminalNode {
	return s.GetToken(DPParserFROM, 0)
}

func (s *ColumnExprSubstringContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnExprSubstringContext) FOR() antlr.TerminalNode {
	return s.GetToken(DPParserFOR, 0)
}

func (s *ColumnExprSubstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprSubstring(s)
	}
}

func (s *ColumnExprSubstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprSubstring(s)
	}
}

func (s *ColumnExprSubstringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprSubstring(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprCastContext struct {
	ColumnExprContext
}

func NewColumnExprCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprCastContext {
	var p = new(ColumnExprCastContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprCastContext) CAST() antlr.TerminalNode {
	return s.GetToken(DPParserCAST, 0)
}

func (s *ColumnExprCastContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnExprCastContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprCastContext) AS() antlr.TerminalNode {
	return s.GetToken(DPParserAS, 0)
}

func (s *ColumnExprCastContext) ColumnTypeExpr() IColumnTypeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *ColumnExprCastContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnExprCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprCast(s)
	}
}

func (s *ColumnExprCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprCast(s)
	}
}

func (s *ColumnExprCastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprOrContext struct {
	ColumnExprContext
}

func NewColumnExprOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprOrContext {
	var p = new(ColumnExprOrContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprOrContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprOrContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprOrContext) OR() antlr.TerminalNode {
	return s.GetToken(DPParserOR, 0)
}

func (s *ColumnExprOrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprOr(s)
	}
}

func (s *ColumnExprOrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprOr(s)
	}
}

func (s *ColumnExprOrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprOr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprPrecedence1Context struct {
	ColumnExprContext
}

func NewColumnExprPrecedence1Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprPrecedence1Context {
	var p = new(ColumnExprPrecedence1Context)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprPrecedence1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprPrecedence1Context) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprPrecedence1Context) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprPrecedence1Context) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DPParserASTERISK, 0)
}

func (s *ColumnExprPrecedence1Context) SLASH() antlr.TerminalNode {
	return s.GetToken(DPParserSLASH, 0)
}

func (s *ColumnExprPrecedence1Context) PERCENT() antlr.TerminalNode {
	return s.GetToken(DPParserPERCENT, 0)
}

func (s *ColumnExprPrecedence1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprPrecedence1(s)
	}
}

func (s *ColumnExprPrecedence1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprPrecedence1(s)
	}
}

func (s *ColumnExprPrecedence1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprPrecedence1(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprPrecedence2Context struct {
	ColumnExprContext
}

func NewColumnExprPrecedence2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprPrecedence2Context {
	var p = new(ColumnExprPrecedence2Context)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprPrecedence2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprPrecedence2Context) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprPrecedence2Context) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprPrecedence2Context) PLUS() antlr.TerminalNode {
	return s.GetToken(DPParserPLUS, 0)
}

func (s *ColumnExprPrecedence2Context) DASH() antlr.TerminalNode {
	return s.GetToken(DPParserDASH, 0)
}

func (s *ColumnExprPrecedence2Context) CONCAT() antlr.TerminalNode {
	return s.GetToken(DPParserCONCAT, 0)
}

func (s *ColumnExprPrecedence2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprPrecedence2(s)
	}
}

func (s *ColumnExprPrecedence2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprPrecedence2(s)
	}
}

func (s *ColumnExprPrecedence2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprPrecedence2(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprPrecedence3Context struct {
	ColumnExprContext
}

func NewColumnExprPrecedence3Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprPrecedence3Context {
	var p = new(ColumnExprPrecedence3Context)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprPrecedence3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprPrecedence3Context) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprPrecedence3Context) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprPrecedence3Context) EQ_DOUBLE() antlr.TerminalNode {
	return s.GetToken(DPParserEQ_DOUBLE, 0)
}

func (s *ColumnExprPrecedence3Context) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(DPParserEQ_SINGLE, 0)
}

func (s *ColumnExprPrecedence3Context) NOT_EQ() antlr.TerminalNode {
	return s.GetToken(DPParserNOT_EQ, 0)
}

func (s *ColumnExprPrecedence3Context) LE() antlr.TerminalNode {
	return s.GetToken(DPParserLE, 0)
}

func (s *ColumnExprPrecedence3Context) GE() antlr.TerminalNode {
	return s.GetToken(DPParserGE, 0)
}

func (s *ColumnExprPrecedence3Context) LT() antlr.TerminalNode {
	return s.GetToken(DPParserLT, 0)
}

func (s *ColumnExprPrecedence3Context) GT() antlr.TerminalNode {
	return s.GetToken(DPParserGT, 0)
}

func (s *ColumnExprPrecedence3Context) IN() antlr.TerminalNode {
	return s.GetToken(DPParserIN, 0)
}

func (s *ColumnExprPrecedence3Context) LIKE() antlr.TerminalNode {
	return s.GetToken(DPParserLIKE, 0)
}

func (s *ColumnExprPrecedence3Context) ILIKE() antlr.TerminalNode {
	return s.GetToken(DPParserILIKE, 0)
}

func (s *ColumnExprPrecedence3Context) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DPParserGLOBAL, 0)
}

func (s *ColumnExprPrecedence3Context) NOT() antlr.TerminalNode {
	return s.GetToken(DPParserNOT, 0)
}

func (s *ColumnExprPrecedence3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprPrecedence3(s)
	}
}

func (s *ColumnExprPrecedence3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprPrecedence3(s)
	}
}

func (s *ColumnExprPrecedence3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprPrecedence3(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprIntervalContext struct {
	ColumnExprContext
}

func NewColumnExprIntervalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprIntervalContext {
	var p = new(ColumnExprIntervalContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprIntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DPParserINTERVAL, 0)
}

func (s *ColumnExprIntervalContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprIntervalContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *ColumnExprIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprInterval(s)
	}
}

func (s *ColumnExprIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprInterval(s)
	}
}

func (s *ColumnExprIntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprIsNullContext struct {
	ColumnExprContext
}

func NewColumnExprIsNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprIsNullContext {
	var p = new(ColumnExprIsNullContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprIsNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprIsNullContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprIsNullContext) IS() antlr.TerminalNode {
	return s.GetToken(DPParserIS, 0)
}

func (s *ColumnExprIsNullContext) NULL_SQL() antlr.TerminalNode {
	return s.GetToken(DPParserNULL_SQL, 0)
}

func (s *ColumnExprIsNullContext) NOT() antlr.TerminalNode {
	return s.GetToken(DPParserNOT, 0)
}

func (s *ColumnExprIsNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprIsNull(s)
	}
}

func (s *ColumnExprIsNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprIsNull(s)
	}
}

func (s *ColumnExprIsNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprIsNull(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprWinFunctionTargetContext struct {
	ColumnExprContext
}

func NewColumnExprWinFunctionTargetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprWinFunctionTargetContext {
	var p = new(ColumnExprWinFunctionTargetContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprWinFunctionTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprWinFunctionTargetContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprWinFunctionTargetContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnExprWinFunctionTargetContext) OVER() antlr.TerminalNode {
	return s.GetToken(DPParserOVER, 0)
}

func (s *ColumnExprWinFunctionTargetContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnExprWinFunctionTargetContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnExprWinFunctionTargetContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprWinFunctionTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprWinFunctionTarget(s)
	}
}

func (s *ColumnExprWinFunctionTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprWinFunctionTarget(s)
	}
}

func (s *ColumnExprWinFunctionTargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprWinFunctionTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprTrimContext struct {
	ColumnExprContext
}

func NewColumnExprTrimContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTrimContext {
	var p = new(ColumnExprTrimContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTrimContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTrimContext) TRIM() antlr.TerminalNode {
	return s.GetToken(DPParserTRIM, 0)
}

func (s *ColumnExprTrimContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnExprTrimContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserSTRING_LITERAL, 0)
}

func (s *ColumnExprTrimContext) FROM() antlr.TerminalNode {
	return s.GetToken(DPParserFROM, 0)
}

func (s *ColumnExprTrimContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprTrimContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnExprTrimContext) BOTH() antlr.TerminalNode {
	return s.GetToken(DPParserBOTH, 0)
}

func (s *ColumnExprTrimContext) LEADING() antlr.TerminalNode {
	return s.GetToken(DPParserLEADING, 0)
}

func (s *ColumnExprTrimContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(DPParserTRAILING, 0)
}

func (s *ColumnExprTrimContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprTrim(s)
	}
}

func (s *ColumnExprTrimContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprTrim(s)
	}
}

func (s *ColumnExprTrimContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprTrim(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprTupleContext struct {
	ColumnExprContext
}

func NewColumnExprTupleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTupleContext {
	var p = new(ColumnExprTupleContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTupleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnExprTupleContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprTupleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnExprTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprTuple(s)
	}
}

func (s *ColumnExprTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprTuple(s)
	}
}

func (s *ColumnExprTupleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprTuple(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprArrayAccessContext struct {
	ColumnExprContext
}

func NewColumnExprArrayAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprArrayAccessContext {
	var p = new(ColumnExprArrayAccessContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprArrayAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprArrayAccessContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprArrayAccessContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprArrayAccessContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(DPParserLBRACKET, 0)
}

func (s *ColumnExprArrayAccessContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(DPParserRBRACKET, 0)
}

func (s *ColumnExprArrayAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprArrayAccess(s)
	}
}

func (s *ColumnExprArrayAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprArrayAccess(s)
	}
}

func (s *ColumnExprArrayAccessContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprArrayAccess(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprBetweenContext struct {
	ColumnExprContext
}

func NewColumnExprBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprBetweenContext {
	var p = new(ColumnExprBetweenContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprBetweenContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprBetweenContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprBetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DPParserBETWEEN, 0)
}

func (s *ColumnExprBetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(DPParserAND, 0)
}

func (s *ColumnExprBetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(DPParserNOT, 0)
}

func (s *ColumnExprBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprBetween(s)
	}
}

func (s *ColumnExprBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprBetween(s)
	}
}

func (s *ColumnExprBetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprParensContext struct {
	ColumnExprContext
}

func NewColumnExprParensContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprParensContext {
	var p = new(ColumnExprParensContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprParensContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnExprParensContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprParensContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnExprParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprParens(s)
	}
}

func (s *ColumnExprParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprParens(s)
	}
}

func (s *ColumnExprParensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprParens(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprTimestampContext struct {
	ColumnExprContext
}

func NewColumnExprTimestampContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTimestampContext {
	var p = new(ColumnExprTimestampContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTimestampContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DPParserTIMESTAMP, 0)
}

func (s *ColumnExprTimestampContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserSTRING_LITERAL, 0)
}

func (s *ColumnExprTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprTimestamp(s)
	}
}

func (s *ColumnExprTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprTimestamp(s)
	}
}

func (s *ColumnExprTimestampContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprTimestamp(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprAndContext struct {
	ColumnExprContext
}

func NewColumnExprAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprAndContext {
	var p = new(ColumnExprAndContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprAndContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprAndContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprAndContext) AND() antlr.TerminalNode {
	return s.GetToken(DPParserAND, 0)
}

func (s *ColumnExprAndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprAnd(s)
	}
}

func (s *ColumnExprAndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprAnd(s)
	}
}

func (s *ColumnExprAndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprAnd(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprTupleAccessContext struct {
	ColumnExprContext
}

func NewColumnExprTupleAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTupleAccessContext {
	var p = new(ColumnExprTupleAccessContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTupleAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTupleAccessContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprTupleAccessContext) DOT() antlr.TerminalNode {
	return s.GetToken(DPParserDOT, 0)
}

func (s *ColumnExprTupleAccessContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserDECIMAL_LITERAL, 0)
}

func (s *ColumnExprTupleAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprTupleAccess(s)
	}
}

func (s *ColumnExprTupleAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprTupleAccess(s)
	}
}

func (s *ColumnExprTupleAccessContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprTupleAccess(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprCaseContext struct {
	ColumnExprContext
}

func NewColumnExprCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprCaseContext {
	var p = new(ColumnExprCaseContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DPParserCASE, 0)
}

func (s *ColumnExprCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DPParserEND, 0)
}

func (s *ColumnExprCaseContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprCaseContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprCaseContext) AllWHEN() []antlr.TerminalNode {
	return s.GetTokens(DPParserWHEN)
}

func (s *ColumnExprCaseContext) WHEN(i int) antlr.TerminalNode {
	return s.GetToken(DPParserWHEN, i)
}

func (s *ColumnExprCaseContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(DPParserTHEN)
}

func (s *ColumnExprCaseContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(DPParserTHEN, i)
}

func (s *ColumnExprCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DPParserELSE, 0)
}

func (s *ColumnExprCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprCase(s)
	}
}

func (s *ColumnExprCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprCase(s)
	}
}

func (s *ColumnExprCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprDateContext struct {
	ColumnExprContext
}

func NewColumnExprDateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprDateContext {
	var p = new(ColumnExprDateContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprDateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprDateContext) DATE() antlr.TerminalNode {
	return s.GetToken(DPParserDATE, 0)
}

func (s *ColumnExprDateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserSTRING_LITERAL, 0)
}

func (s *ColumnExprDateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprDate(s)
	}
}

func (s *ColumnExprDateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprDate(s)
	}
}

func (s *ColumnExprDateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprDate(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprNotContext struct {
	ColumnExprContext
}

func NewColumnExprNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprNotContext {
	var p = new(ColumnExprNotContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(DPParserNOT, 0)
}

func (s *ColumnExprNotContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprNot(s)
	}
}

func (s *ColumnExprNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprNot(s)
	}
}

func (s *ColumnExprNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprWinFunctionContext struct {
	ColumnExprContext
}

func NewColumnExprWinFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprWinFunctionContext {
	var p = new(ColumnExprWinFunctionContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprWinFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprWinFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnExprWinFunctionContext) OVER() antlr.TerminalNode {
	return s.GetToken(DPParserOVER, 0)
}

func (s *ColumnExprWinFunctionContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(DPParserLPAREN)
}

func (s *ColumnExprWinFunctionContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, i)
}

func (s *ColumnExprWinFunctionContext) WindowExpr() IWindowExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowExprContext)
}

func (s *ColumnExprWinFunctionContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(DPParserRPAREN)
}

func (s *ColumnExprWinFunctionContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, i)
}

func (s *ColumnExprWinFunctionContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprWinFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprWinFunction(s)
	}
}

func (s *ColumnExprWinFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprWinFunction(s)
	}
}

func (s *ColumnExprWinFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprWinFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprIdentifierContext struct {
	ColumnExprContext
}

func NewColumnExprIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprIdentifierContext {
	var p = new(ColumnExprIdentifierContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprIdentifierContext) ColumnIdentifier() IColumnIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnIdentifierContext)
}

func (s *ColumnExprIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprIdentifier(s)
	}
}

func (s *ColumnExprIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprIdentifier(s)
	}
}

func (s *ColumnExprIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprFunctionContext struct {
	ColumnExprContext
}

func NewColumnExprFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprFunctionContext {
	var p = new(ColumnExprFunctionContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnExprFunctionContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(DPParserLPAREN)
}

func (s *ColumnExprFunctionContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, i)
}

func (s *ColumnExprFunctionContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(DPParserRPAREN)
}

func (s *ColumnExprFunctionContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, i)
}

func (s *ColumnExprFunctionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DPParserDISTINCT, 0)
}

func (s *ColumnExprFunctionContext) ColumnArgList() IColumnArgListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnArgListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnArgListContext)
}

func (s *ColumnExprFunctionContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprFunction(s)
	}
}

func (s *ColumnExprFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprFunction(s)
	}
}

func (s *ColumnExprFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnExprAsteriskContext struct {
	ColumnExprContext
}

func NewColumnExprAsteriskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprAsteriskContext {
	var p = new(ColumnExprAsteriskContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DPParserASTERISK, 0)
}

func (s *ColumnExprAsteriskContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ColumnExprAsteriskContext) DOT() antlr.TerminalNode {
	return s.GetToken(DPParserDOT, 0)
}

func (s *ColumnExprAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnExprAsterisk(s)
	}
}

func (s *ColumnExprAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnExprAsterisk(s)
	}
}

func (s *ColumnExprAsteriskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnExprAsterisk(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) ColumnExpr() (localctx IColumnExprContext) {
	return p.columnExpr(0)
}

func (p *DPParser) columnExpr(_p int) (localctx IColumnExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewColumnExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IColumnExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 86
	p.EnterRecursionRule(localctx, 86, DPParserRULE_columnExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnExprCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(575)
			p.Match(DPParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(577)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(576)
				p.columnExpr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DPParserWHEN {
			{
				p.SetState(579)
				p.Match(DPParserWHEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(580)
				p.columnExpr(0)
			}
			{
				p.SetState(581)
				p.Match(DPParserTHEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(582)
				p.columnExpr(0)
			}

			p.SetState(586)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DPParserELSE {
			{
				p.SetState(588)
				p.Match(DPParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(589)
				p.columnExpr(0)
			}

		}
		{
			p.SetState(592)
			p.Match(DPParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewColumnExprCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(594)
			p.Match(DPParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(595)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(596)
			p.columnExpr(0)
		}
		{
			p.SetState(597)
			p.Match(DPParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(598)
			p.ColumnTypeExpr()
		}
		{
			p.SetState(599)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewColumnExprDateContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(601)
			p.Match(DPParserDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(602)
			p.Match(DPParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewColumnExprExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(603)
			p.Match(DPParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(604)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(605)
			p.Interval()
		}
		{
			p.SetState(606)
			p.Match(DPParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(607)
			p.columnExpr(0)
		}
		{
			p.SetState(608)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewColumnExprIntervalContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(610)
			p.Match(DPParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(611)
			p.columnExpr(0)
		}
		{
			p.SetState(612)
			p.Interval()
		}

	case 6:
		localctx = NewColumnExprSubstringContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(614)
			p.Match(DPParserSUBSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(615)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(616)
			p.columnExpr(0)
		}
		{
			p.SetState(617)
			p.Match(DPParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(618)
			p.columnExpr(0)
		}
		p.SetState(621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DPParserFOR {
			{
				p.SetState(619)
				p.Match(DPParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(620)
				p.columnExpr(0)
			}

		}
		{
			p.SetState(623)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewColumnExprTimestampContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(625)
			p.Match(DPParserTIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(626)
			p.Match(DPParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewColumnExprTrimContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(627)
			p.Match(DPParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(628)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(629)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DPParserBOTH || _la == DPParserLEADING || _la == DPParserTRAILING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(630)
			p.Match(DPParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(631)
			p.Match(DPParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(632)
			p.columnExpr(0)
		}
		{
			p.SetState(633)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewColumnExprWinFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(635)
			p.Identifier()
		}

		{
			p.SetState(636)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4294967301) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&144753023) != 0) {
			{
				p.SetState(637)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(640)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(642)
			p.Match(DPParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(643)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(644)
			p.WindowExpr()
		}
		{
			p.SetState(645)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewColumnExprWinFunctionTargetContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(647)
			p.Identifier()
		}

		{
			p.SetState(648)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4294967301) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&144753023) != 0) {
			{
				p.SetState(649)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(652)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(654)
			p.Match(DPParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(655)
			p.Identifier()
		}

	case 11:
		localctx = NewColumnExprFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(657)
			p.Identifier()
		}
		p.SetState(663)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(658)
				p.Match(DPParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(660)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4294967301) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&144753023) != 0) {
				{
					p.SetState(659)
					p.ColumnExprList()
				}

			}
			{
				p.SetState(662)
				p.Match(DPParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(665)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(667)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(666)
				p.Match(DPParserDISTINCT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4294967301) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&144753023) != 0) {
			{
				p.SetState(669)
				p.ColumnArgList()
			}

		}
		{
			p.SetState(672)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewColumnExprLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(674)
			p.Literal()
		}

	case 13:
		localctx = NewColumnExprBraceParamContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(675)
			p.Match(DPParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(676)
			p.Match(DPParserLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(677)
			p.Literal()
		}
		{
			p.SetState(678)
			p.Match(DPParserRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewColumnExprNegateContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(680)
			p.Match(DPParserDASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(681)
			p.columnExpr(17)
		}

	case 15:
		localctx = NewColumnExprNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(682)
			p.Match(DPParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(683)
			p.columnExpr(12)
		}

	case 16:
		localctx = NewColumnExprAsteriskContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(687)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-2)) & ^0x3f) == 0 && ((int64(1)<<(_la-2))&-1) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-633318697631745) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&9223372036317904895) != 0) {
			{
				p.SetState(684)
				p.TableIdentifier()
			}
			{
				p.SetState(685)
				p.Match(DPParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(689)
			p.Match(DPParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewColumnExprSubqueryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(690)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(691)
			p.SelectUnionStmt()
		}
		{
			p.SetState(692)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewColumnExprParensContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(694)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(695)
			p.columnExpr(0)
		}
		{
			p.SetState(696)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewColumnExprTupleContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(698)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(699)
			p.ColumnExprList()
		}
		{
			p.SetState(700)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewColumnExprArrayContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(702)
			p.Match(DPParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(704)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4294967301) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&144753023) != 0) {
			{
				p.SetState(703)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(706)
			p.Match(DPParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewColumnExprIdentifierContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(707)
			p.ColumnIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(779)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) {
			case 1:
				localctx = NewColumnExprPrecedence1Context(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DPParserRULE_columnExpr)
				p.SetState(710)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(711)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-200)) & ^0x3f) == 0 && ((int64(1)<<(_la-200))&134479873) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(712)
					p.columnExpr(17)
				}

			case 2:
				localctx = NewColumnExprPrecedence2Context(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DPParserRULE_columnExpr)
				p.SetState(713)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(714)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-205)) & ^0x3f) == 0 && ((int64(1)<<(_la-205))&16387) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(715)
					p.columnExpr(16)
				}

			case 3:
				localctx = NewColumnExprPrecedence3Context(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DPParserRULE_columnExpr)
				p.SetState(716)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				p.SetState(735)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(717)
						p.Match(DPParserEQ_DOUBLE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					{
						p.SetState(718)
						p.Match(DPParserEQ_SINGLE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 3:
					{
						p.SetState(719)
						p.Match(DPParserNOT_EQ)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 4:
					{
						p.SetState(720)
						p.Match(DPParserLE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 5:
					{
						p.SetState(721)
						p.Match(DPParserGE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 6:
					{
						p.SetState(722)
						p.Match(DPParserLT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 7:
					{
						p.SetState(723)
						p.Match(DPParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 8:
					p.SetState(725)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == DPParserGLOBAL {
						{
							p.SetState(724)
							p.Match(DPParserGLOBAL)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					p.SetState(728)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == DPParserNOT {
						{
							p.SetState(727)
							p.Match(DPParserNOT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(730)
						p.Match(DPParserIN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 9:
					p.SetState(732)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == DPParserNOT {
						{
							p.SetState(731)
							p.Match(DPParserNOT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(734)
						_la = p.GetTokenStream().LA(1)

						if !(_la == DPParserILIKE || _la == DPParserLIKE) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(737)
					p.columnExpr(15)
				}

			case 4:
				localctx = NewColumnExprAndContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DPParserRULE_columnExpr)
				p.SetState(738)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(739)
					p.Match(DPParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(740)
					p.columnExpr(12)
				}

			case 5:
				localctx = NewColumnExprOrContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DPParserRULE_columnExpr)
				p.SetState(741)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(742)
					p.Match(DPParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(743)
					p.columnExpr(11)
				}

			case 6:
				localctx = NewColumnExprBetweenContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DPParserRULE_columnExpr)
				p.SetState(744)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				p.SetState(746)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DPParserNOT {
					{
						p.SetState(745)
						p.Match(DPParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(748)
					p.Match(DPParserBETWEEN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(749)
					p.columnExpr(0)
				}
				{
					p.SetState(750)
					p.Match(DPParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(751)
					p.columnExpr(10)
				}

			case 7:
				localctx = NewColumnExprTernaryOpContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DPParserRULE_columnExpr)
				p.SetState(753)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(754)
					p.Match(DPParserQUERY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(755)
					p.columnExpr(0)
				}
				{
					p.SetState(756)
					p.Match(DPParserCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(757)
					p.columnExpr(8)
				}

			case 8:
				localctx = NewColumnExprArrayAccessContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DPParserRULE_columnExpr)
				p.SetState(759)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(760)
					p.Match(DPParserLBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(761)
					p.columnExpr(0)
				}
				{
					p.SetState(762)
					p.Match(DPParserRBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 9:
				localctx = NewColumnExprTupleAccessContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DPParserRULE_columnExpr)
				p.SetState(764)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(765)
					p.Match(DPParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(766)
					p.Match(DPParserDECIMAL_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 10:
				localctx = NewColumnExprIsNullContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DPParserRULE_columnExpr)
				p.SetState(767)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(768)
					p.Match(DPParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(770)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DPParserNOT {
					{
						p.SetState(769)
						p.Match(DPParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(772)
					p.Match(DPParserNULL_SQL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 11:
				localctx = NewColumnExprAliasContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DPParserRULE_columnExpr)
				p.SetState(773)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				p.SetState(777)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DPParserDATE, DPParserFIRST, DPParserID, DPParserKEY, DPParserIDENTIFIER:
					{
						p.SetState(774)
						p.Alias()
					}

				case DPParserAS:
					{
						p.SetState(775)
						p.Match(DPParserAS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(776)
						p.Identifier()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnArgListContext is an interface to support dynamic dispatch.
type IColumnArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnArgExpr() []IColumnArgExprContext
	ColumnArgExpr(i int) IColumnArgExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnArgListContext differentiates from other interfaces.
	IsColumnArgListContext()
}

type ColumnArgListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnArgListContext() *ColumnArgListContext {
	var p = new(ColumnArgListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnArgList
	return p
}

func InitEmptyColumnArgListContext(p *ColumnArgListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnArgList
}

func (*ColumnArgListContext) IsColumnArgListContext() {}

func NewColumnArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnArgListContext {
	var p = new(ColumnArgListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_columnArgList

	return p
}

func (s *ColumnArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnArgListContext) AllColumnArgExpr() []IColumnArgExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnArgExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnArgExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnArgExprContext); ok {
			tst[i] = t.(IColumnArgExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnArgListContext) ColumnArgExpr(i int) IColumnArgExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnArgExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnArgExprContext)
}

func (s *ColumnArgListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DPParserCOMMA)
}

func (s *ColumnArgListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, i)
}

func (s *ColumnArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnArgList(s)
	}
}

func (s *ColumnArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnArgList(s)
	}
}

func (s *ColumnArgListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnArgList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) ColumnArgList() (localctx IColumnArgListContext) {
	localctx = NewColumnArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, DPParserRULE_columnArgList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.ColumnArgExpr()
	}
	p.SetState(789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DPParserCOMMA {
		{
			p.SetState(785)
			p.Match(DPParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(786)
			p.ColumnArgExpr()
		}

		p.SetState(791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnArgExprContext is an interface to support dynamic dispatch.
type IColumnArgExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnLambdaExpr() IColumnLambdaExprContext
	ColumnExpr() IColumnExprContext

	// IsColumnArgExprContext differentiates from other interfaces.
	IsColumnArgExprContext()
}

type ColumnArgExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnArgExprContext() *ColumnArgExprContext {
	var p = new(ColumnArgExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnArgExpr
	return p
}

func InitEmptyColumnArgExprContext(p *ColumnArgExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnArgExpr
}

func (*ColumnArgExprContext) IsColumnArgExprContext() {}

func NewColumnArgExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnArgExprContext {
	var p = new(ColumnArgExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_columnArgExpr

	return p
}

func (s *ColumnArgExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnArgExprContext) ColumnLambdaExpr() IColumnLambdaExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnLambdaExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnLambdaExprContext)
}

func (s *ColumnArgExprContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnArgExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnArgExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnArgExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnArgExpr(s)
	}
}

func (s *ColumnArgExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnArgExpr(s)
	}
}

func (s *ColumnArgExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnArgExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) ColumnArgExpr() (localctx IColumnArgExprContext) {
	localctx = NewColumnArgExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, DPParserRULE_columnArgExpr)
	p.SetState(794)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(792)
			p.ColumnLambdaExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(793)
			p.columnExpr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnLambdaExprContext is an interface to support dynamic dispatch.
type IColumnLambdaExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARROW() antlr.TerminalNode
	ColumnExpr() IColumnExprContext
	LPAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnLambdaExprContext differentiates from other interfaces.
	IsColumnLambdaExprContext()
}

type ColumnLambdaExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnLambdaExprContext() *ColumnLambdaExprContext {
	var p = new(ColumnLambdaExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnLambdaExpr
	return p
}

func InitEmptyColumnLambdaExprContext(p *ColumnLambdaExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnLambdaExpr
}

func (*ColumnLambdaExprContext) IsColumnLambdaExprContext() {}

func NewColumnLambdaExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnLambdaExprContext {
	var p = new(ColumnLambdaExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_columnLambdaExpr

	return p
}

func (s *ColumnLambdaExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnLambdaExprContext) ARROW() antlr.TerminalNode {
	return s.GetToken(DPParserARROW, 0)
}

func (s *ColumnLambdaExprContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnLambdaExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *ColumnLambdaExprContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnLambdaExprContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnLambdaExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *ColumnLambdaExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DPParserCOMMA)
}

func (s *ColumnLambdaExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, i)
}

func (s *ColumnLambdaExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnLambdaExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnLambdaExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnLambdaExpr(s)
	}
}

func (s *ColumnLambdaExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnLambdaExpr(s)
	}
}

func (s *ColumnLambdaExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnLambdaExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) ColumnLambdaExpr() (localctx IColumnLambdaExprContext) {
	localctx = NewColumnLambdaExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, DPParserRULE_columnLambdaExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DPParserLPAREN:
		{
			p.SetState(796)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(797)
			p.Identifier()
		}
		p.SetState(802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DPParserCOMMA {
			{
				p.SetState(798)
				p.Match(DPParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(799)
				p.Identifier()
			}

			p.SetState(804)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(805)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DPParserAFTER, DPParserALIAS, DPParserALL, DPParserALTER, DPParserAND, DPParserANTI, DPParserANY, DPParserARRAY, DPParserAS, DPParserASCENDING, DPParserASOF, DPParserAST, DPParserASYNC, DPParserATTACH, DPParserBETWEEN, DPParserBOTH, DPParserBY, DPParserCASE, DPParserCAST, DPParserCHECK, DPParserCLEAR, DPParserCLUSTER, DPParserCODEC, DPParserCOLLATE, DPParserCOLUMN, DPParserCOMMENT, DPParserCONSTRAINT, DPParserCREATE, DPParserCROSS, DPParserCUBE, DPParserCURRENT, DPParserDATABASE, DPParserDATABASES, DPParserDATE, DPParserDAY, DPParserDEDUPLICATE, DPParserDEFAULT, DPParserDELAY, DPParserDELETE, DPParserDESC, DPParserDESCENDING, DPParserDESCRIBE, DPParserDETACH, DPParserDICTIONARIES, DPParserDICTIONARY, DPParserDISK, DPParserDISTINCT, DPParserDISTRIBUTED, DPParserDROP, DPParserELSE, DPParserEND, DPParserENGINE, DPParserEVENTS, DPParserEXISTS, DPParserEXPLAIN, DPParserEXPRESSION, DPParserEXTRACT, DPParserFETCHES, DPParserFINAL, DPParserFIRST, DPParserFLUSH, DPParserFOLLOWING, DPParserFOR, DPParserFORMAT, DPParserFREEZE, DPParserFROM, DPParserFULL, DPParserFUNCTION, DPParserGLOBAL, DPParserGRANULARITY, DPParserGROUP, DPParserHAVING, DPParserHIERARCHICAL, DPParserHOUR, DPParserID, DPParserIF, DPParserILIKE, DPParserIN, DPParserINDEX, DPParserINJECTIVE, DPParserINNER, DPParserINSERT, DPParserINTERVAL, DPParserINTO, DPParserIS, DPParserIS_OBJECT_ID, DPParserJOIN, DPParserKEY, DPParserKILL, DPParserLAST, DPParserLAYOUT, DPParserLEADING, DPParserLEFT, DPParserLIFETIME, DPParserLIKE, DPParserLIMIT, DPParserLIVE, DPParserLOCAL, DPParserLOGS, DPParserMATERIALIZE, DPParserMATERIALIZED, DPParserMAX, DPParserMERGES, DPParserMIN, DPParserMINUTE, DPParserMODIFY, DPParserMONTH, DPParserMOVE, DPParserMUTATION, DPParserNO, DPParserNOT, DPParserNULLS, DPParserOFFSET, DPParserON, DPParserOPTIMIZE, DPParserOR, DPParserORDER, DPParserOUTER, DPParserOUTFILE, DPParserOVER, DPParserPARTITION, DPParserPOPULATE, DPParserPRECEDING, DPParserPREWHERE, DPParserPRIMARY, DPParserQUARTER, DPParserRANGE, DPParserRELOAD, DPParserREMOVE, DPParserRENAME, DPParserREPLACE, DPParserREPLICA, DPParserREPLICATED, DPParserRIGHT, DPParserROLLUP, DPParserROW, DPParserROWS, DPParserSAMPLE, DPParserSECOND, DPParserSELECT, DPParserSEMI, DPParserSENDS, DPParserSET, DPParserSETTINGS, DPParserSHOW, DPParserSOURCE, DPParserSTART, DPParserSTOP, DPParserSUBSTRING, DPParserSYNC, DPParserSYNTAX, DPParserSYSTEM, DPParserTABLE, DPParserTABLES, DPParserTEMPORARY, DPParserTEST, DPParserTHEN, DPParserTIES, DPParserTIMEOUT, DPParserTIMESTAMP, DPParserTO, DPParserTOP, DPParserTOTALS, DPParserTRAILING, DPParserTRIM, DPParserTRUNCATE, DPParserTTL, DPParserTYPE, DPParserUNBOUNDED, DPParserUNION, DPParserUPDATE, DPParserUSE, DPParserUSING, DPParserUUID, DPParserVALUES, DPParserVIEW, DPParserVOLUME, DPParserWATCH, DPParserWEEK, DPParserWHEN, DPParserWHERE, DPParserWINDOW, DPParserWITH, DPParserYEAR, DPParserJSON_FALSE, DPParserJSON_TRUE, DPParserIDENTIFIER:
		{
			p.SetState(807)
			p.Identifier()
		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DPParserCOMMA {
			{
				p.SetState(808)
				p.Match(DPParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(809)
				p.Identifier()
			}

			p.SetState(814)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(817)
		p.Match(DPParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(818)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnIdentifierContext is an interface to support dynamic dispatch.
type IColumnIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NestedIdentifier() INestedIdentifierContext
	TableIdentifier() ITableIdentifierContext
	DOT() antlr.TerminalNode

	// IsColumnIdentifierContext differentiates from other interfaces.
	IsColumnIdentifierContext()
}

type ColumnIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnIdentifierContext() *ColumnIdentifierContext {
	var p = new(ColumnIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnIdentifier
	return p
}

func InitEmptyColumnIdentifierContext(p *ColumnIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_columnIdentifier
}

func (*ColumnIdentifierContext) IsColumnIdentifierContext() {}

func NewColumnIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnIdentifierContext {
	var p = new(ColumnIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_columnIdentifier

	return p
}

func (s *ColumnIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnIdentifierContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *ColumnIdentifierContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ColumnIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(DPParserDOT, 0)
}

func (s *ColumnIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterColumnIdentifier(s)
	}
}

func (s *ColumnIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitColumnIdentifier(s)
	}
}

func (s *ColumnIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitColumnIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) ColumnIdentifier() (localctx IColumnIdentifierContext) {
	localctx = NewColumnIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, DPParserRULE_columnIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(823)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(820)
			p.TableIdentifier()
		}
		{
			p.SetState(821)
			p.Match(DPParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(825)
		p.NestedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedIdentifierContext is an interface to support dynamic dispatch.
type INestedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	DOT() antlr.TerminalNode

	// IsNestedIdentifierContext differentiates from other interfaces.
	IsNestedIdentifierContext()
}

type NestedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedIdentifierContext() *NestedIdentifierContext {
	var p = new(NestedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_nestedIdentifier
	return p
}

func InitEmptyNestedIdentifierContext(p *NestedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_nestedIdentifier
}

func (*NestedIdentifierContext) IsNestedIdentifierContext() {}

func NewNestedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedIdentifierContext {
	var p = new(NestedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_nestedIdentifier

	return p
}

func (s *NestedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedIdentifierContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *NestedIdentifierContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NestedIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(DPParserDOT, 0)
}

func (s *NestedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterNestedIdentifier(s)
	}
}

func (s *NestedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitNestedIdentifier(s)
	}
}

func (s *NestedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitNestedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) NestedIdentifier() (localctx INestedIdentifierContext) {
	localctx = NewNestedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, DPParserRULE_nestedIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		p.Identifier()
	}
	p.SetState(830)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(828)
			p.Match(DPParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(829)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableExprContext is an interface to support dynamic dispatch.
type ITableExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableExprContext differentiates from other interfaces.
	IsTableExprContext()
}

type TableExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableExprContext() *TableExprContext {
	var p = new(TableExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tableExpr
	return p
}

func InitEmptyTableExprContext(p *TableExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tableExpr
}

func (*TableExprContext) IsTableExprContext() {}

func NewTableExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableExprContext {
	var p = new(TableExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_tableExpr

	return p
}

func (s *TableExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableExprContext) CopyAll(ctx *TableExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableExprIdentifierContext struct {
	TableExprContext
}

func NewTableExprIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExprIdentifierContext {
	var p = new(TableExprIdentifierContext)

	InitEmptyTableExprContext(&p.TableExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableExprContext))

	return p
}

func (s *TableExprIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprIdentifierContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *TableExprIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterTableExprIdentifier(s)
	}
}

func (s *TableExprIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitTableExprIdentifier(s)
	}
}

func (s *TableExprIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitTableExprIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableExprSubqueryContext struct {
	TableExprContext
}

func NewTableExprSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExprSubqueryContext {
	var p = new(TableExprSubqueryContext)

	InitEmptyTableExprContext(&p.TableExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableExprContext))

	return p
}

func (s *TableExprSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprSubqueryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *TableExprSubqueryContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *TableExprSubqueryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *TableExprSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterTableExprSubquery(s)
	}
}

func (s *TableExprSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitTableExprSubquery(s)
	}
}

func (s *TableExprSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitTableExprSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableExprAliasContext struct {
	TableExprContext
}

func NewTableExprAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExprAliasContext {
	var p = new(TableExprAliasContext)

	InitEmptyTableExprContext(&p.TableExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableExprContext))

	return p
}

func (s *TableExprAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprAliasContext) TableExpr() ITableExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableExprContext)
}

func (s *TableExprAliasContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *TableExprAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(DPParserAS, 0)
}

func (s *TableExprAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableExprAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterTableExprAlias(s)
	}
}

func (s *TableExprAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitTableExprAlias(s)
	}
}

func (s *TableExprAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitTableExprAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableExprFunctionContext struct {
	TableExprContext
}

func NewTableExprFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExprFunctionContext {
	var p = new(TableExprFunctionContext)

	InitEmptyTableExprContext(&p.TableExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableExprContext))

	return p
}

func (s *TableExprFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprFunctionContext) TableFunctionExpr() ITableFunctionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFunctionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFunctionExprContext)
}

func (s *TableExprFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterTableExprFunction(s)
	}
}

func (s *TableExprFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitTableExprFunction(s)
	}
}

func (s *TableExprFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitTableExprFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) TableExpr() (localctx ITableExprContext) {
	return p.tableExpr(0)
}

func (p *DPParser) tableExpr(_p int) (localctx ITableExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewTableExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITableExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 98
	p.EnterRecursionRule(localctx, 98, DPParserRULE_tableExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableExprIdentifierContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(833)
			p.TableIdentifier()
		}

	case 2:
		localctx = NewTableExprFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(834)
			p.TableFunctionExpr()
		}

	case 3:
		localctx = NewTableExprSubqueryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(835)
			p.Match(DPParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(836)
			p.SelectUnionStmt()
		}
		{
			p.SetState(837)
			p.Match(DPParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTableExprAliasContext(p, NewTableExprContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, DPParserRULE_tableExpr)
			p.SetState(841)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			p.SetState(845)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DPParserDATE, DPParserFIRST, DPParserID, DPParserKEY, DPParserIDENTIFIER:
				{
					p.SetState(842)
					p.Alias()
				}

			case DPParserAS:
				{
					p.SetState(843)
					p.Match(DPParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(844)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableFunctionExprContext is an interface to support dynamic dispatch.
type ITableFunctionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TableArgList() ITableArgListContext

	// IsTableFunctionExprContext differentiates from other interfaces.
	IsTableFunctionExprContext()
}

type TableFunctionExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableFunctionExprContext() *TableFunctionExprContext {
	var p = new(TableFunctionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tableFunctionExpr
	return p
}

func InitEmptyTableFunctionExprContext(p *TableFunctionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tableFunctionExpr
}

func (*TableFunctionExprContext) IsTableFunctionExprContext() {}

func NewTableFunctionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFunctionExprContext {
	var p = new(TableFunctionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_tableFunctionExpr

	return p
}

func (s *TableFunctionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFunctionExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableFunctionExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserLPAREN, 0)
}

func (s *TableFunctionExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DPParserRPAREN, 0)
}

func (s *TableFunctionExprContext) TableArgList() ITableArgListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableArgListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableArgListContext)
}

func (s *TableFunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFunctionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableFunctionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterTableFunctionExpr(s)
	}
}

func (s *TableFunctionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitTableFunctionExpr(s)
	}
}

func (s *TableFunctionExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitTableFunctionExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) TableFunctionExpr() (localctx ITableFunctionExprContext) {
	localctx = NewTableFunctionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, DPParserRULE_tableFunctionExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(852)
		p.Identifier()
	}
	{
		p.SetState(853)
		p.Match(DPParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4294967301) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&134267007) != 0) {
		{
			p.SetState(854)
			p.TableArgList()
		}

	}
	{
		p.SetState(857)
		p.Match(DPParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableIdentifierContext is an interface to support dynamic dispatch.
type ITableIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DatabaseIdentifier() IDatabaseIdentifierContext
	DOT() antlr.TerminalNode

	// IsTableIdentifierContext differentiates from other interfaces.
	IsTableIdentifierContext()
}

type TableIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableIdentifierContext() *TableIdentifierContext {
	var p = new(TableIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tableIdentifier
	return p
}

func InitEmptyTableIdentifierContext(p *TableIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tableIdentifier
}

func (*TableIdentifierContext) IsTableIdentifierContext() {}

func NewTableIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableIdentifierContext {
	var p = new(TableIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_tableIdentifier

	return p
}

func (s *TableIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TableIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableIdentifierContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *TableIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(DPParserDOT, 0)
}

func (s *TableIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterTableIdentifier(s)
	}
}

func (s *TableIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitTableIdentifier(s)
	}
}

func (s *TableIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitTableIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) TableIdentifier() (localctx ITableIdentifierContext) {
	localctx = NewTableIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, DPParserRULE_tableIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(862)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(859)
			p.DatabaseIdentifier()
		}
		{
			p.SetState(860)
			p.Match(DPParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(864)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableArgListContext is an interface to support dynamic dispatch.
type ITableArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableArgExpr() []ITableArgExprContext
	TableArgExpr(i int) ITableArgExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableArgListContext differentiates from other interfaces.
	IsTableArgListContext()
}

type TableArgListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableArgListContext() *TableArgListContext {
	var p = new(TableArgListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tableArgList
	return p
}

func InitEmptyTableArgListContext(p *TableArgListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tableArgList
}

func (*TableArgListContext) IsTableArgListContext() {}

func NewTableArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableArgListContext {
	var p = new(TableArgListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_tableArgList

	return p
}

func (s *TableArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableArgListContext) AllTableArgExpr() []ITableArgExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableArgExprContext); ok {
			len++
		}
	}

	tst := make([]ITableArgExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableArgExprContext); ok {
			tst[i] = t.(ITableArgExprContext)
			i++
		}
	}

	return tst
}

func (s *TableArgListContext) TableArgExpr(i int) ITableArgExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableArgExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableArgExprContext)
}

func (s *TableArgListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DPParserCOMMA)
}

func (s *TableArgListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DPParserCOMMA, i)
}

func (s *TableArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterTableArgList(s)
	}
}

func (s *TableArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitTableArgList(s)
	}
}

func (s *TableArgListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitTableArgList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) TableArgList() (localctx ITableArgListContext) {
	localctx = NewTableArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, DPParserRULE_tableArgList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		p.TableArgExpr()
	}
	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DPParserCOMMA {
		{
			p.SetState(867)
			p.Match(DPParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(868)
			p.TableArgExpr()
		}

		p.SetState(873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableArgExprContext is an interface to support dynamic dispatch.
type ITableArgExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NestedIdentifier() INestedIdentifierContext
	TableFunctionExpr() ITableFunctionExprContext
	Literal() ILiteralContext

	// IsTableArgExprContext differentiates from other interfaces.
	IsTableArgExprContext()
}

type TableArgExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableArgExprContext() *TableArgExprContext {
	var p = new(TableArgExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tableArgExpr
	return p
}

func InitEmptyTableArgExprContext(p *TableArgExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_tableArgExpr
}

func (*TableArgExprContext) IsTableArgExprContext() {}

func NewTableArgExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableArgExprContext {
	var p = new(TableArgExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_tableArgExpr

	return p
}

func (s *TableArgExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableArgExprContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *TableArgExprContext) TableFunctionExpr() ITableFunctionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFunctionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFunctionExprContext)
}

func (s *TableArgExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *TableArgExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableArgExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableArgExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterTableArgExpr(s)
	}
}

func (s *TableArgExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitTableArgExpr(s)
	}
}

func (s *TableArgExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitTableArgExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) TableArgExpr() (localctx ITableArgExprContext) {
	localctx = NewTableArgExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, DPParserRULE_tableArgExpr)
	p.SetState(877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(874)
			p.NestedIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(875)
			p.TableFunctionExpr()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(876)
			p.Literal()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabaseIdentifierContext is an interface to support dynamic dispatch.
type IDatabaseIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsDatabaseIdentifierContext differentiates from other interfaces.
	IsDatabaseIdentifierContext()
}

type DatabaseIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabaseIdentifierContext() *DatabaseIdentifierContext {
	var p = new(DatabaseIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_databaseIdentifier
	return p
}

func InitEmptyDatabaseIdentifierContext(p *DatabaseIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_databaseIdentifier
}

func (*DatabaseIdentifierContext) IsDatabaseIdentifierContext() {}

func NewDatabaseIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseIdentifierContext {
	var p = new(DatabaseIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_databaseIdentifier

	return p
}

func (s *DatabaseIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DatabaseIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabaseIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterDatabaseIdentifier(s)
	}
}

func (s *DatabaseIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitDatabaseIdentifier(s)
	}
}

func (s *DatabaseIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitDatabaseIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) DatabaseIdentifier() (localctx IDatabaseIdentifierContext) {
	localctx = NewDatabaseIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, DPParserRULE_databaseIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloatingLiteralContext is an interface to support dynamic dispatch.
type IFloatingLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOATING_LITERAL() antlr.TerminalNode
	DOT() antlr.TerminalNode
	AllDECIMAL_LITERAL() []antlr.TerminalNode
	DECIMAL_LITERAL(i int) antlr.TerminalNode
	OCTAL_LITERAL() antlr.TerminalNode

	// IsFloatingLiteralContext differentiates from other interfaces.
	IsFloatingLiteralContext()
}

type FloatingLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatingLiteralContext() *FloatingLiteralContext {
	var p = new(FloatingLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_floatingLiteral
	return p
}

func InitEmptyFloatingLiteralContext(p *FloatingLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_floatingLiteral
}

func (*FloatingLiteralContext) IsFloatingLiteralContext() {}

func NewFloatingLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatingLiteralContext {
	var p = new(FloatingLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_floatingLiteral

	return p
}

func (s *FloatingLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatingLiteralContext) FLOATING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserFLOATING_LITERAL, 0)
}

func (s *FloatingLiteralContext) DOT() antlr.TerminalNode {
	return s.GetToken(DPParserDOT, 0)
}

func (s *FloatingLiteralContext) AllDECIMAL_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DPParserDECIMAL_LITERAL)
}

func (s *FloatingLiteralContext) DECIMAL_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DPParserDECIMAL_LITERAL, i)
}

func (s *FloatingLiteralContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserOCTAL_LITERAL, 0)
}

func (s *FloatingLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatingLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatingLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterFloatingLiteral(s)
	}
}

func (s *FloatingLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitFloatingLiteral(s)
	}
}

func (s *FloatingLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitFloatingLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) FloatingLiteral() (localctx IFloatingLiteralContext) {
	localctx = NewFloatingLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, DPParserRULE_floatingLiteral)
	var _la int

	p.SetState(889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DPParserFLOATING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(881)
			p.Match(DPParserFLOATING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DPParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(882)
			p.Match(DPParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(883)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DPParserOCTAL_LITERAL || _la == DPParserDECIMAL_LITERAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DPParserDECIMAL_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(884)
			p.Match(DPParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(885)
			p.Match(DPParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(887)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(886)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DPParserOCTAL_LITERAL || _la == DPParserDECIMAL_LITERAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FloatingLiteral() IFloatingLiteralContext
	OCTAL_LITERAL() antlr.TerminalNode
	DECIMAL_LITERAL() antlr.TerminalNode
	HEXADECIMAL_LITERAL() antlr.TerminalNode
	INF() antlr.TerminalNode
	NAN_SQL() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	DASH() antlr.TerminalNode

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_numberLiteral
	return p
}

func InitEmptyNumberLiteralContext(p *NumberLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_numberLiteral
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) FloatingLiteral() IFloatingLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatingLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatingLiteralContext)
}

func (s *NumberLiteralContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserOCTAL_LITERAL, 0)
}

func (s *NumberLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserDECIMAL_LITERAL, 0)
}

func (s *NumberLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserHEXADECIMAL_LITERAL, 0)
}

func (s *NumberLiteralContext) INF() antlr.TerminalNode {
	return s.GetToken(DPParserINF, 0)
}

func (s *NumberLiteralContext) NAN_SQL() antlr.TerminalNode {
	return s.GetToken(DPParserNAN_SQL, 0)
}

func (s *NumberLiteralContext) PLUS() antlr.TerminalNode {
	return s.GetToken(DPParserPLUS, 0)
}

func (s *NumberLiteralContext) DASH() antlr.TerminalNode {
	return s.GetToken(DPParserDASH, 0)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitNumberLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, DPParserRULE_numberLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(892)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DPParserDASH || _la == DPParserPLUS {
		{
			p.SetState(891)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DPParserDASH || _la == DPParserPLUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(894)
			p.FloatingLiteral()
		}

	case 2:
		{
			p.SetState(895)
			p.Match(DPParserOCTAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(896)
			p.Match(DPParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(897)
			p.Match(DPParserHEXADECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(898)
			p.Match(DPParserINF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		{
			p.SetState(899)
			p.Match(DPParserNAN_SQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumberLiteral() INumberLiteralContext
	STRING_LITERAL() antlr.TerminalNode
	NULL_SQL() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserSTRING_LITERAL, 0)
}

func (s *LiteralContext) NULL_SQL() antlr.TerminalNode {
	return s.GetToken(DPParserNULL_SQL, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, DPParserRULE_literal)
	p.SetState(905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DPParserINF, DPParserNAN_SQL, DPParserFLOATING_LITERAL, DPParserOCTAL_LITERAL, DPParserDECIMAL_LITERAL, DPParserHEXADECIMAL_LITERAL, DPParserDASH, DPParserDOT, DPParserPLUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(902)
			p.NumberLiteral()
		}

	case DPParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(903)
			p.Match(DPParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DPParserNULL_SQL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(904)
			p.Match(DPParserNULL_SQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SECOND() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	DAY() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	YEAR() antlr.TerminalNode

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DPParserSECOND, 0)
}

func (s *IntervalContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DPParserMINUTE, 0)
}

func (s *IntervalContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DPParserHOUR, 0)
}

func (s *IntervalContext) DAY() antlr.TerminalNode {
	return s.GetToken(DPParserDAY, 0)
}

func (s *IntervalContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DPParserWEEK, 0)
}

func (s *IntervalContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DPParserMONTH, 0)
}

func (s *IntervalContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DPParserQUARTER, 0)
}

func (s *IntervalContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DPParserYEAR, 0)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (s *IntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, DPParserRULE_interval)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(907)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DPParserDAY || ((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&72057615512764417) != 0) || ((int64((_la-144)) & ^0x3f) == 0 && ((int64(1)<<(_la-144))&72567767433217) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AFTER() antlr.TerminalNode
	ALIAS() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	AND() antlr.TerminalNode
	ANTI() antlr.TerminalNode
	ANY() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	AS() antlr.TerminalNode
	ASCENDING() antlr.TerminalNode
	ASOF() antlr.TerminalNode
	AST() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	ATTACH() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	BOTH() antlr.TerminalNode
	BY() antlr.TerminalNode
	CASE() antlr.TerminalNode
	CAST() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	CLEAR() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CODEC() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DEDUPLICATE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DELAY() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCENDING() antlr.TerminalNode
	DETACH() antlr.TerminalNode
	DICTIONARIES() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	DROP() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	END() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	EXPRESSION() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	FETCHES() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FLUSH() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FREEZE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANULARITY() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	HAVING() antlr.TerminalNode
	HIERARCHICAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	IF() antlr.TerminalNode
	ILIKE() antlr.TerminalNode
	IN() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INJECTIVE() antlr.TerminalNode
	INNER() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	INTO() antlr.TerminalNode
	IS() antlr.TerminalNode
	IS_OBJECT_ID() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	JSON_FALSE() antlr.TerminalNode
	JSON_TRUE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	KILL() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LAYOUT() antlr.TerminalNode
	LEADING() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LIFETIME() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	LIVE() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	MATERIALIZE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MERGES() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MOVE() antlr.TerminalNode
	MUTATION() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOT() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ON() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	OR() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	OVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	POPULATE() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PREWHERE() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	REPLICATED() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROW() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	SENDS() antlr.TerminalNode
	SET() antlr.TerminalNode
	SETTINGS() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	START() antlr.TerminalNode
	STOP() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYNTAX() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEST() antlr.TerminalNode
	THEN() antlr.TerminalNode
	TIES() antlr.TerminalNode
	TIMEOUT() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TOTALS() antlr.TerminalNode
	TRAILING() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TO() antlr.TerminalNode
	TOP() antlr.TerminalNode
	TTL() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNION() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USE() antlr.TerminalNode
	USING() antlr.TerminalNode
	UUID() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	WATCH() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	WINDOW() antlr.TerminalNode
	WITH() antlr.TerminalNode

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_keyword
	return p
}

func InitEmptyKeywordContext(p *KeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_keyword
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DPParserAFTER, 0)
}

func (s *KeywordContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(DPParserALIAS, 0)
}

func (s *KeywordContext) ALL() antlr.TerminalNode {
	return s.GetToken(DPParserALL, 0)
}

func (s *KeywordContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DPParserALTER, 0)
}

func (s *KeywordContext) AND() antlr.TerminalNode {
	return s.GetToken(DPParserAND, 0)
}

func (s *KeywordContext) ANTI() antlr.TerminalNode {
	return s.GetToken(DPParserANTI, 0)
}

func (s *KeywordContext) ANY() antlr.TerminalNode {
	return s.GetToken(DPParserANY, 0)
}

func (s *KeywordContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DPParserARRAY, 0)
}

func (s *KeywordContext) AS() antlr.TerminalNode {
	return s.GetToken(DPParserAS, 0)
}

func (s *KeywordContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(DPParserASCENDING, 0)
}

func (s *KeywordContext) ASOF() antlr.TerminalNode {
	return s.GetToken(DPParserASOF, 0)
}

func (s *KeywordContext) AST() antlr.TerminalNode {
	return s.GetToken(DPParserAST, 0)
}

func (s *KeywordContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(DPParserASYNC, 0)
}

func (s *KeywordContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(DPParserATTACH, 0)
}

func (s *KeywordContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DPParserBETWEEN, 0)
}

func (s *KeywordContext) BOTH() antlr.TerminalNode {
	return s.GetToken(DPParserBOTH, 0)
}

func (s *KeywordContext) BY() antlr.TerminalNode {
	return s.GetToken(DPParserBY, 0)
}

func (s *KeywordContext) CASE() antlr.TerminalNode {
	return s.GetToken(DPParserCASE, 0)
}

func (s *KeywordContext) CAST() antlr.TerminalNode {
	return s.GetToken(DPParserCAST, 0)
}

func (s *KeywordContext) CHECK() antlr.TerminalNode {
	return s.GetToken(DPParserCHECK, 0)
}

func (s *KeywordContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(DPParserCLEAR, 0)
}

func (s *KeywordContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DPParserCLUSTER, 0)
}

func (s *KeywordContext) CODEC() antlr.TerminalNode {
	return s.GetToken(DPParserCODEC, 0)
}

func (s *KeywordContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DPParserCOLLATE, 0)
}

func (s *KeywordContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DPParserCOLUMN, 0)
}

func (s *KeywordContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DPParserCOMMENT, 0)
}

func (s *KeywordContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(DPParserCONSTRAINT, 0)
}

func (s *KeywordContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DPParserCREATE, 0)
}

func (s *KeywordContext) CROSS() antlr.TerminalNode {
	return s.GetToken(DPParserCROSS, 0)
}

func (s *KeywordContext) CUBE() antlr.TerminalNode {
	return s.GetToken(DPParserCUBE, 0)
}

func (s *KeywordContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(DPParserCURRENT, 0)
}

func (s *KeywordContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DPParserDATABASE, 0)
}

func (s *KeywordContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(DPParserDATABASES, 0)
}

func (s *KeywordContext) DATE() antlr.TerminalNode {
	return s.GetToken(DPParserDATE, 0)
}

func (s *KeywordContext) DEDUPLICATE() antlr.TerminalNode {
	return s.GetToken(DPParserDEDUPLICATE, 0)
}

func (s *KeywordContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DPParserDEFAULT, 0)
}

func (s *KeywordContext) DELAY() antlr.TerminalNode {
	return s.GetToken(DPParserDELAY, 0)
}

func (s *KeywordContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DPParserDELETE, 0)
}

func (s *KeywordContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DPParserDESCRIBE, 0)
}

func (s *KeywordContext) DESC() antlr.TerminalNode {
	return s.GetToken(DPParserDESC, 0)
}

func (s *KeywordContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(DPParserDESCENDING, 0)
}

func (s *KeywordContext) DETACH() antlr.TerminalNode {
	return s.GetToken(DPParserDETACH, 0)
}

func (s *KeywordContext) DICTIONARIES() antlr.TerminalNode {
	return s.GetToken(DPParserDICTIONARIES, 0)
}

func (s *KeywordContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DPParserDICTIONARY, 0)
}

func (s *KeywordContext) DISK() antlr.TerminalNode {
	return s.GetToken(DPParserDISK, 0)
}

func (s *KeywordContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DPParserDISTINCT, 0)
}

func (s *KeywordContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DPParserDISTRIBUTED, 0)
}

func (s *KeywordContext) DROP() antlr.TerminalNode {
	return s.GetToken(DPParserDROP, 0)
}

func (s *KeywordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DPParserELSE, 0)
}

func (s *KeywordContext) END() antlr.TerminalNode {
	return s.GetToken(DPParserEND, 0)
}

func (s *KeywordContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DPParserENGINE, 0)
}

func (s *KeywordContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(DPParserEVENTS, 0)
}

func (s *KeywordContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DPParserEXISTS, 0)
}

func (s *KeywordContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(DPParserEXPLAIN, 0)
}

func (s *KeywordContext) EXPRESSION() antlr.TerminalNode {
	return s.GetToken(DPParserEXPRESSION, 0)
}

func (s *KeywordContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(DPParserEXTRACT, 0)
}

func (s *KeywordContext) FETCHES() antlr.TerminalNode {
	return s.GetToken(DPParserFETCHES, 0)
}

func (s *KeywordContext) FINAL() antlr.TerminalNode {
	return s.GetToken(DPParserFINAL, 0)
}

func (s *KeywordContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DPParserFIRST, 0)
}

func (s *KeywordContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(DPParserFLUSH, 0)
}

func (s *KeywordContext) FOR() antlr.TerminalNode {
	return s.GetToken(DPParserFOR, 0)
}

func (s *KeywordContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(DPParserFOLLOWING, 0)
}

func (s *KeywordContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DPParserFORMAT, 0)
}

func (s *KeywordContext) FREEZE() antlr.TerminalNode {
	return s.GetToken(DPParserFREEZE, 0)
}

func (s *KeywordContext) FROM() antlr.TerminalNode {
	return s.GetToken(DPParserFROM, 0)
}

func (s *KeywordContext) FULL() antlr.TerminalNode {
	return s.GetToken(DPParserFULL, 0)
}

func (s *KeywordContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DPParserFUNCTION, 0)
}

func (s *KeywordContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DPParserGLOBAL, 0)
}

func (s *KeywordContext) GRANULARITY() antlr.TerminalNode {
	return s.GetToken(DPParserGRANULARITY, 0)
}

func (s *KeywordContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DPParserGROUP, 0)
}

func (s *KeywordContext) HAVING() antlr.TerminalNode {
	return s.GetToken(DPParserHAVING, 0)
}

func (s *KeywordContext) HIERARCHICAL() antlr.TerminalNode {
	return s.GetToken(DPParserHIERARCHICAL, 0)
}

func (s *KeywordContext) ID() antlr.TerminalNode {
	return s.GetToken(DPParserID, 0)
}

func (s *KeywordContext) IF() antlr.TerminalNode {
	return s.GetToken(DPParserIF, 0)
}

func (s *KeywordContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(DPParserILIKE, 0)
}

func (s *KeywordContext) IN() antlr.TerminalNode {
	return s.GetToken(DPParserIN, 0)
}

func (s *KeywordContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DPParserINDEX, 0)
}

func (s *KeywordContext) INJECTIVE() antlr.TerminalNode {
	return s.GetToken(DPParserINJECTIVE, 0)
}

func (s *KeywordContext) INNER() antlr.TerminalNode {
	return s.GetToken(DPParserINNER, 0)
}

func (s *KeywordContext) INSERT() antlr.TerminalNode {
	return s.GetToken(DPParserINSERT, 0)
}

func (s *KeywordContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DPParserINTERVAL, 0)
}

func (s *KeywordContext) INTO() antlr.TerminalNode {
	return s.GetToken(DPParserINTO, 0)
}

func (s *KeywordContext) IS() antlr.TerminalNode {
	return s.GetToken(DPParserIS, 0)
}

func (s *KeywordContext) IS_OBJECT_ID() antlr.TerminalNode {
	return s.GetToken(DPParserIS_OBJECT_ID, 0)
}

func (s *KeywordContext) JOIN() antlr.TerminalNode {
	return s.GetToken(DPParserJOIN, 0)
}

func (s *KeywordContext) JSON_FALSE() antlr.TerminalNode {
	return s.GetToken(DPParserJSON_FALSE, 0)
}

func (s *KeywordContext) JSON_TRUE() antlr.TerminalNode {
	return s.GetToken(DPParserJSON_TRUE, 0)
}

func (s *KeywordContext) KEY() antlr.TerminalNode {
	return s.GetToken(DPParserKEY, 0)
}

func (s *KeywordContext) KILL() antlr.TerminalNode {
	return s.GetToken(DPParserKILL, 0)
}

func (s *KeywordContext) LAST() antlr.TerminalNode {
	return s.GetToken(DPParserLAST, 0)
}

func (s *KeywordContext) LAYOUT() antlr.TerminalNode {
	return s.GetToken(DPParserLAYOUT, 0)
}

func (s *KeywordContext) LEADING() antlr.TerminalNode {
	return s.GetToken(DPParserLEADING, 0)
}

func (s *KeywordContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DPParserLEFT, 0)
}

func (s *KeywordContext) LIFETIME() antlr.TerminalNode {
	return s.GetToken(DPParserLIFETIME, 0)
}

func (s *KeywordContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DPParserLIKE, 0)
}

func (s *KeywordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DPParserLIMIT, 0)
}

func (s *KeywordContext) LIVE() antlr.TerminalNode {
	return s.GetToken(DPParserLIVE, 0)
}

func (s *KeywordContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DPParserLOCAL, 0)
}

func (s *KeywordContext) LOGS() antlr.TerminalNode {
	return s.GetToken(DPParserLOGS, 0)
}

func (s *KeywordContext) MATERIALIZE() antlr.TerminalNode {
	return s.GetToken(DPParserMATERIALIZE, 0)
}

func (s *KeywordContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DPParserMATERIALIZED, 0)
}

func (s *KeywordContext) MAX() antlr.TerminalNode {
	return s.GetToken(DPParserMAX, 0)
}

func (s *KeywordContext) MERGES() antlr.TerminalNode {
	return s.GetToken(DPParserMERGES, 0)
}

func (s *KeywordContext) MIN() antlr.TerminalNode {
	return s.GetToken(DPParserMIN, 0)
}

func (s *KeywordContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DPParserMODIFY, 0)
}

func (s *KeywordContext) MOVE() antlr.TerminalNode {
	return s.GetToken(DPParserMOVE, 0)
}

func (s *KeywordContext) MUTATION() antlr.TerminalNode {
	return s.GetToken(DPParserMUTATION, 0)
}

func (s *KeywordContext) NO() antlr.TerminalNode {
	return s.GetToken(DPParserNO, 0)
}

func (s *KeywordContext) NOT() antlr.TerminalNode {
	return s.GetToken(DPParserNOT, 0)
}

func (s *KeywordContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DPParserNULLS, 0)
}

func (s *KeywordContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DPParserOFFSET, 0)
}

func (s *KeywordContext) ON() antlr.TerminalNode {
	return s.GetToken(DPParserON, 0)
}

func (s *KeywordContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(DPParserOPTIMIZE, 0)
}

func (s *KeywordContext) OR() antlr.TerminalNode {
	return s.GetToken(DPParserOR, 0)
}

func (s *KeywordContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DPParserORDER, 0)
}

func (s *KeywordContext) OUTER() antlr.TerminalNode {
	return s.GetToken(DPParserOUTER, 0)
}

func (s *KeywordContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(DPParserOUTFILE, 0)
}

func (s *KeywordContext) OVER() antlr.TerminalNode {
	return s.GetToken(DPParserOVER, 0)
}

func (s *KeywordContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DPParserPARTITION, 0)
}

func (s *KeywordContext) POPULATE() antlr.TerminalNode {
	return s.GetToken(DPParserPOPULATE, 0)
}

func (s *KeywordContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DPParserPRECEDING, 0)
}

func (s *KeywordContext) PREWHERE() antlr.TerminalNode {
	return s.GetToken(DPParserPREWHERE, 0)
}

func (s *KeywordContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(DPParserPRIMARY, 0)
}

func (s *KeywordContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DPParserRANGE, 0)
}

func (s *KeywordContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(DPParserRELOAD, 0)
}

func (s *KeywordContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(DPParserREMOVE, 0)
}

func (s *KeywordContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DPParserRENAME, 0)
}

func (s *KeywordContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DPParserREPLACE, 0)
}

func (s *KeywordContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DPParserREPLICA, 0)
}

func (s *KeywordContext) REPLICATED() antlr.TerminalNode {
	return s.GetToken(DPParserREPLICATED, 0)
}

func (s *KeywordContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DPParserRIGHT, 0)
}

func (s *KeywordContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DPParserROLLUP, 0)
}

func (s *KeywordContext) ROW() antlr.TerminalNode {
	return s.GetToken(DPParserROW, 0)
}

func (s *KeywordContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DPParserROWS, 0)
}

func (s *KeywordContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DPParserSAMPLE, 0)
}

func (s *KeywordContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DPParserSELECT, 0)
}

func (s *KeywordContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DPParserSEMI, 0)
}

func (s *KeywordContext) SENDS() antlr.TerminalNode {
	return s.GetToken(DPParserSENDS, 0)
}

func (s *KeywordContext) SET() antlr.TerminalNode {
	return s.GetToken(DPParserSET, 0)
}

func (s *KeywordContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(DPParserSETTINGS, 0)
}

func (s *KeywordContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DPParserSHOW, 0)
}

func (s *KeywordContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(DPParserSOURCE, 0)
}

func (s *KeywordContext) START() antlr.TerminalNode {
	return s.GetToken(DPParserSTART, 0)
}

func (s *KeywordContext) STOP() antlr.TerminalNode {
	return s.GetToken(DPParserSTOP, 0)
}

func (s *KeywordContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(DPParserSUBSTRING, 0)
}

func (s *KeywordContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DPParserSYNC, 0)
}

func (s *KeywordContext) SYNTAX() antlr.TerminalNode {
	return s.GetToken(DPParserSYNTAX, 0)
}

func (s *KeywordContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DPParserSYSTEM, 0)
}

func (s *KeywordContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DPParserTABLE, 0)
}

func (s *KeywordContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DPParserTABLES, 0)
}

func (s *KeywordContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DPParserTEMPORARY, 0)
}

func (s *KeywordContext) TEST() antlr.TerminalNode {
	return s.GetToken(DPParserTEST, 0)
}

func (s *KeywordContext) THEN() antlr.TerminalNode {
	return s.GetToken(DPParserTHEN, 0)
}

func (s *KeywordContext) TIES() antlr.TerminalNode {
	return s.GetToken(DPParserTIES, 0)
}

func (s *KeywordContext) TIMEOUT() antlr.TerminalNode {
	return s.GetToken(DPParserTIMEOUT, 0)
}

func (s *KeywordContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DPParserTIMESTAMP, 0)
}

func (s *KeywordContext) TOTALS() antlr.TerminalNode {
	return s.GetToken(DPParserTOTALS, 0)
}

func (s *KeywordContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(DPParserTRAILING, 0)
}

func (s *KeywordContext) TRIM() antlr.TerminalNode {
	return s.GetToken(DPParserTRIM, 0)
}

func (s *KeywordContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DPParserTRUNCATE, 0)
}

func (s *KeywordContext) TO() antlr.TerminalNode {
	return s.GetToken(DPParserTO, 0)
}

func (s *KeywordContext) TOP() antlr.TerminalNode {
	return s.GetToken(DPParserTOP, 0)
}

func (s *KeywordContext) TTL() antlr.TerminalNode {
	return s.GetToken(DPParserTTL, 0)
}

func (s *KeywordContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DPParserTYPE, 0)
}

func (s *KeywordContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DPParserUNBOUNDED, 0)
}

func (s *KeywordContext) UNION() antlr.TerminalNode {
	return s.GetToken(DPParserUNION, 0)
}

func (s *KeywordContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DPParserUPDATE, 0)
}

func (s *KeywordContext) USE() antlr.TerminalNode {
	return s.GetToken(DPParserUSE, 0)
}

func (s *KeywordContext) USING() antlr.TerminalNode {
	return s.GetToken(DPParserUSING, 0)
}

func (s *KeywordContext) UUID() antlr.TerminalNode {
	return s.GetToken(DPParserUUID, 0)
}

func (s *KeywordContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DPParserVALUES, 0)
}

func (s *KeywordContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DPParserVIEW, 0)
}

func (s *KeywordContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(DPParserVOLUME, 0)
}

func (s *KeywordContext) WATCH() antlr.TerminalNode {
	return s.GetToken(DPParserWATCH, 0)
}

func (s *KeywordContext) WHEN() antlr.TerminalNode {
	return s.GetToken(DPParserWHEN, 0)
}

func (s *KeywordContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DPParserWHERE, 0)
}

func (s *KeywordContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(DPParserWINDOW, 0)
}

func (s *KeywordContext) WITH() antlr.TerminalNode {
	return s.GetToken(DPParserWITH, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (s *KeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, DPParserRULE_keyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(909)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-2)) & ^0x3f) == 0 && ((int64(1)<<(_la-2))&-17179869185) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-644313813910017) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&2008605433538801663) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordForAliasContext is an interface to support dynamic dispatch.
type IKeywordForAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	ID() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsKeywordForAliasContext differentiates from other interfaces.
	IsKeywordForAliasContext()
}

type KeywordForAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordForAliasContext() *KeywordForAliasContext {
	var p = new(KeywordForAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_keywordForAlias
	return p
}

func InitEmptyKeywordForAliasContext(p *KeywordForAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_keywordForAlias
}

func (*KeywordForAliasContext) IsKeywordForAliasContext() {}

func NewKeywordForAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordForAliasContext {
	var p = new(KeywordForAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_keywordForAlias

	return p
}

func (s *KeywordForAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordForAliasContext) DATE() antlr.TerminalNode {
	return s.GetToken(DPParserDATE, 0)
}

func (s *KeywordForAliasContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DPParserFIRST, 0)
}

func (s *KeywordForAliasContext) ID() antlr.TerminalNode {
	return s.GetToken(DPParserID, 0)
}

func (s *KeywordForAliasContext) KEY() antlr.TerminalNode {
	return s.GetToken(DPParserKEY, 0)
}

func (s *KeywordForAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordForAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordForAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterKeywordForAlias(s)
	}
}

func (s *KeywordForAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitKeywordForAlias(s)
	}
}

func (s *KeywordForAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitKeywordForAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) KeywordForAlias() (localctx IKeywordForAliasContext) {
	localctx = NewKeywordForAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, DPParserRULE_keywordForAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(911)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-35)) & ^0x3f) == 0 && ((int64(1)<<(_la-35))&36030996109328385) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	KeywordForAlias() IKeywordForAliasContext

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_alias
	return p
}

func InitEmptyAliasContext(p *AliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_alias
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DPParserIDENTIFIER, 0)
}

func (s *AliasContext) KeywordForAlias() IKeywordForAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordForAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordForAliasContext)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitAlias(s)
	}
}

func (s *AliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) Alias() (localctx IAliasContext) {
	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, DPParserRULE_alias)
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DPParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(913)
			p.Match(DPParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DPParserDATE, DPParserFIRST, DPParserID, DPParserKEY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(914)
			p.KeywordForAlias()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Interval() IIntervalContext
	Keyword() IKeywordContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DPParserIDENTIFIER, 0)
}

func (s *IdentifierContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IdentifierContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, DPParserRULE_identifier)
	p.SetState(920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DPParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(917)
			p.Match(DPParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DPParserDAY, DPParserHOUR, DPParserMINUTE, DPParserMONTH, DPParserQUARTER, DPParserSECOND, DPParserWEEK, DPParserYEAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(918)
			p.Interval()
		}

	case DPParserAFTER, DPParserALIAS, DPParserALL, DPParserALTER, DPParserAND, DPParserANTI, DPParserANY, DPParserARRAY, DPParserAS, DPParserASCENDING, DPParserASOF, DPParserAST, DPParserASYNC, DPParserATTACH, DPParserBETWEEN, DPParserBOTH, DPParserBY, DPParserCASE, DPParserCAST, DPParserCHECK, DPParserCLEAR, DPParserCLUSTER, DPParserCODEC, DPParserCOLLATE, DPParserCOLUMN, DPParserCOMMENT, DPParserCONSTRAINT, DPParserCREATE, DPParserCROSS, DPParserCUBE, DPParserCURRENT, DPParserDATABASE, DPParserDATABASES, DPParserDATE, DPParserDEDUPLICATE, DPParserDEFAULT, DPParserDELAY, DPParserDELETE, DPParserDESC, DPParserDESCENDING, DPParserDESCRIBE, DPParserDETACH, DPParserDICTIONARIES, DPParserDICTIONARY, DPParserDISK, DPParserDISTINCT, DPParserDISTRIBUTED, DPParserDROP, DPParserELSE, DPParserEND, DPParserENGINE, DPParserEVENTS, DPParserEXISTS, DPParserEXPLAIN, DPParserEXPRESSION, DPParserEXTRACT, DPParserFETCHES, DPParserFINAL, DPParserFIRST, DPParserFLUSH, DPParserFOLLOWING, DPParserFOR, DPParserFORMAT, DPParserFREEZE, DPParserFROM, DPParserFULL, DPParserFUNCTION, DPParserGLOBAL, DPParserGRANULARITY, DPParserGROUP, DPParserHAVING, DPParserHIERARCHICAL, DPParserID, DPParserIF, DPParserILIKE, DPParserIN, DPParserINDEX, DPParserINJECTIVE, DPParserINNER, DPParserINSERT, DPParserINTERVAL, DPParserINTO, DPParserIS, DPParserIS_OBJECT_ID, DPParserJOIN, DPParserKEY, DPParserKILL, DPParserLAST, DPParserLAYOUT, DPParserLEADING, DPParserLEFT, DPParserLIFETIME, DPParserLIKE, DPParserLIMIT, DPParserLIVE, DPParserLOCAL, DPParserLOGS, DPParserMATERIALIZE, DPParserMATERIALIZED, DPParserMAX, DPParserMERGES, DPParserMIN, DPParserMODIFY, DPParserMOVE, DPParserMUTATION, DPParserNO, DPParserNOT, DPParserNULLS, DPParserOFFSET, DPParserON, DPParserOPTIMIZE, DPParserOR, DPParserORDER, DPParserOUTER, DPParserOUTFILE, DPParserOVER, DPParserPARTITION, DPParserPOPULATE, DPParserPRECEDING, DPParserPREWHERE, DPParserPRIMARY, DPParserRANGE, DPParserRELOAD, DPParserREMOVE, DPParserRENAME, DPParserREPLACE, DPParserREPLICA, DPParserREPLICATED, DPParserRIGHT, DPParserROLLUP, DPParserROW, DPParserROWS, DPParserSAMPLE, DPParserSELECT, DPParserSEMI, DPParserSENDS, DPParserSET, DPParserSETTINGS, DPParserSHOW, DPParserSOURCE, DPParserSTART, DPParserSTOP, DPParserSUBSTRING, DPParserSYNC, DPParserSYNTAX, DPParserSYSTEM, DPParserTABLE, DPParserTABLES, DPParserTEMPORARY, DPParserTEST, DPParserTHEN, DPParserTIES, DPParserTIMEOUT, DPParserTIMESTAMP, DPParserTO, DPParserTOP, DPParserTOTALS, DPParserTRAILING, DPParserTRIM, DPParserTRUNCATE, DPParserTTL, DPParserTYPE, DPParserUNBOUNDED, DPParserUNION, DPParserUPDATE, DPParserUSE, DPParserUSING, DPParserUUID, DPParserVALUES, DPParserVIEW, DPParserVOLUME, DPParserWATCH, DPParserWHEN, DPParserWHERE, DPParserWINDOW, DPParserWITH, DPParserJSON_FALSE, DPParserJSON_TRUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(919)
			p.Keyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrNullContext is an interface to support dynamic dispatch.
type IIdentifierOrNullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	NULL_SQL() antlr.TerminalNode

	// IsIdentifierOrNullContext differentiates from other interfaces.
	IsIdentifierOrNullContext()
}

type IdentifierOrNullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrNullContext() *IdentifierOrNullContext {
	var p = new(IdentifierOrNullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_identifierOrNull
	return p
}

func InitEmptyIdentifierOrNullContext(p *IdentifierOrNullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_identifierOrNull
}

func (*IdentifierOrNullContext) IsIdentifierOrNullContext() {}

func NewIdentifierOrNullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrNullContext {
	var p = new(IdentifierOrNullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_identifierOrNull

	return p
}

func (s *IdentifierOrNullContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrNullContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrNullContext) NULL_SQL() antlr.TerminalNode {
	return s.GetToken(DPParserNULL_SQL, 0)
}

func (s *IdentifierOrNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrNullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterIdentifierOrNull(s)
	}
}

func (s *IdentifierOrNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitIdentifierOrNull(s)
	}
}

func (s *IdentifierOrNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitIdentifierOrNull(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) IdentifierOrNull() (localctx IIdentifierOrNullContext) {
	localctx = NewIdentifierOrNullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, DPParserRULE_identifierOrNull)
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DPParserAFTER, DPParserALIAS, DPParserALL, DPParserALTER, DPParserAND, DPParserANTI, DPParserANY, DPParserARRAY, DPParserAS, DPParserASCENDING, DPParserASOF, DPParserAST, DPParserASYNC, DPParserATTACH, DPParserBETWEEN, DPParserBOTH, DPParserBY, DPParserCASE, DPParserCAST, DPParserCHECK, DPParserCLEAR, DPParserCLUSTER, DPParserCODEC, DPParserCOLLATE, DPParserCOLUMN, DPParserCOMMENT, DPParserCONSTRAINT, DPParserCREATE, DPParserCROSS, DPParserCUBE, DPParserCURRENT, DPParserDATABASE, DPParserDATABASES, DPParserDATE, DPParserDAY, DPParserDEDUPLICATE, DPParserDEFAULT, DPParserDELAY, DPParserDELETE, DPParserDESC, DPParserDESCENDING, DPParserDESCRIBE, DPParserDETACH, DPParserDICTIONARIES, DPParserDICTIONARY, DPParserDISK, DPParserDISTINCT, DPParserDISTRIBUTED, DPParserDROP, DPParserELSE, DPParserEND, DPParserENGINE, DPParserEVENTS, DPParserEXISTS, DPParserEXPLAIN, DPParserEXPRESSION, DPParserEXTRACT, DPParserFETCHES, DPParserFINAL, DPParserFIRST, DPParserFLUSH, DPParserFOLLOWING, DPParserFOR, DPParserFORMAT, DPParserFREEZE, DPParserFROM, DPParserFULL, DPParserFUNCTION, DPParserGLOBAL, DPParserGRANULARITY, DPParserGROUP, DPParserHAVING, DPParserHIERARCHICAL, DPParserHOUR, DPParserID, DPParserIF, DPParserILIKE, DPParserIN, DPParserINDEX, DPParserINJECTIVE, DPParserINNER, DPParserINSERT, DPParserINTERVAL, DPParserINTO, DPParserIS, DPParserIS_OBJECT_ID, DPParserJOIN, DPParserKEY, DPParserKILL, DPParserLAST, DPParserLAYOUT, DPParserLEADING, DPParserLEFT, DPParserLIFETIME, DPParserLIKE, DPParserLIMIT, DPParserLIVE, DPParserLOCAL, DPParserLOGS, DPParserMATERIALIZE, DPParserMATERIALIZED, DPParserMAX, DPParserMERGES, DPParserMIN, DPParserMINUTE, DPParserMODIFY, DPParserMONTH, DPParserMOVE, DPParserMUTATION, DPParserNO, DPParserNOT, DPParserNULLS, DPParserOFFSET, DPParserON, DPParserOPTIMIZE, DPParserOR, DPParserORDER, DPParserOUTER, DPParserOUTFILE, DPParserOVER, DPParserPARTITION, DPParserPOPULATE, DPParserPRECEDING, DPParserPREWHERE, DPParserPRIMARY, DPParserQUARTER, DPParserRANGE, DPParserRELOAD, DPParserREMOVE, DPParserRENAME, DPParserREPLACE, DPParserREPLICA, DPParserREPLICATED, DPParserRIGHT, DPParserROLLUP, DPParserROW, DPParserROWS, DPParserSAMPLE, DPParserSECOND, DPParserSELECT, DPParserSEMI, DPParserSENDS, DPParserSET, DPParserSETTINGS, DPParserSHOW, DPParserSOURCE, DPParserSTART, DPParserSTOP, DPParserSUBSTRING, DPParserSYNC, DPParserSYNTAX, DPParserSYSTEM, DPParserTABLE, DPParserTABLES, DPParserTEMPORARY, DPParserTEST, DPParserTHEN, DPParserTIES, DPParserTIMEOUT, DPParserTIMESTAMP, DPParserTO, DPParserTOP, DPParserTOTALS, DPParserTRAILING, DPParserTRIM, DPParserTRUNCATE, DPParserTTL, DPParserTYPE, DPParserUNBOUNDED, DPParserUNION, DPParserUPDATE, DPParserUSE, DPParserUSING, DPParserUUID, DPParserVALUES, DPParserVIEW, DPParserVOLUME, DPParserWATCH, DPParserWEEK, DPParserWHEN, DPParserWHERE, DPParserWINDOW, DPParserWITH, DPParserYEAR, DPParserJSON_FALSE, DPParserJSON_TRUE, DPParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(922)
			p.Identifier()
		}

	case DPParserNULL_SQL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(923)
			p.Match(DPParserNULL_SQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumValueContext is an interface to support dynamic dispatch.
type IEnumValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	EQ_SINGLE() antlr.TerminalNode
	NumberLiteral() INumberLiteralContext

	// IsEnumValueContext differentiates from other interfaces.
	IsEnumValueContext()
}

type EnumValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueContext() *EnumValueContext {
	var p = new(EnumValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_enumValue
	return p
}

func InitEmptyEnumValueContext(p *EnumValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DPParserRULE_enumValue
}

func (*EnumValueContext) IsEnumValueContext() {}

func NewEnumValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueContext {
	var p = new(EnumValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DPParserRULE_enumValue

	return p
}

func (s *EnumValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DPParserSTRING_LITERAL, 0)
}

func (s *EnumValueContext) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(DPParserEQ_SINGLE, 0)
}

func (s *EnumValueContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *EnumValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.EnterEnumValue(s)
	}
}

func (s *EnumValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DPListener); ok {
		listenerT.ExitEnumValue(s)
	}
}

func (s *EnumValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DPVisitor:
		return t.VisitEnumValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DPParser) EnumValue() (localctx IEnumValueContext) {
	localctx = NewEnumValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, DPParserRULE_enumValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		p.Match(DPParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(927)
		p.Match(DPParserEQ_SINGLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(928)
		p.NumberLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *DPParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 22:
		var t *JoinExprContext = nil
		if localctx != nil {
			t = localctx.(*JoinExprContext)
		}
		return p.JoinExpr_Sempred(t, predIndex)

	case 43:
		var t *ColumnExprContext = nil
		if localctx != nil {
			t = localctx.(*ColumnExprContext)
		}
		return p.ColumnExpr_Sempred(t, predIndex)

	case 49:
		var t *TableExprContext = nil
		if localctx != nil {
			t = localctx.(*TableExprContext)
		}
		return p.TableExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *DPParser) JoinExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DPParser) ColumnExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 7)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DPParser) TableExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 12:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
